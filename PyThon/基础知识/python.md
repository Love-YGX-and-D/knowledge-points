# 计算机时间

## unix时间点

> 1970年1月1日 00：00：00

# 特点

> 可读性强  简洁   面向对象    免费/开源     可移植和跨平台    丰富的库    可扩展性
>
> python中,一切皆对象.每个对象有:标识(identity),类型(type),值(value)组成
>
> 对象的本质: 一个内存快,拥有特定的值,支持特定类型的相关操作

# Python程序的构成

> 模块，一个模块对应一个源文件（py文件）

> 模块由语句构成，一个模块多条语句，按顺序执行

> 语句是python程序的构造单元，用于创建对象、变量赋值、循环控制等

# 创建虚拟环境

1. 创建环境
   `python3 -m venv  虚拟环境名字`
2. 进入环境
   `source /bin/activate`
3. 退出环境
   `deactivate`

# python文件后缀名解析

>  -*- coding: UTF-8 -*-

## py

以 py 扩展名的文件是 Python 源码文件，由 python.exe 解释，可在控制台下运行。可用文本编辑器读写。

## pyc

以 pyc 为扩展名的是Python的编译文件。其执行速度快于 py 文件且不能用文本编辑编辑查看。所以 pyc 文件往往代替 py 文件发布。 
Python 在执行时，首先会将 py 文件中的源代码编译成 PyCodeObject 写入 pyc 文件，再由虚拟机执行 PyCodeObject。当 Python 执行 import 时会先寻找对应的 pyc或 pyd（dll）文件，如果没有则将对应的py文件编译写入 pyc 文件。pyc文件也可以通过 python -m py_compile src.py 生成。

## pyw

pyw 文件与 pyc 文件相似，但 pyw 执行的时候不会出控制台窗口。开发（纯图形界面程序）时可以暂时把 pyw 改成 py 以调出控制台窗口调试。【GUI】

## pyo

pyo 是优化编译后的程序,不能用文本编辑器编辑。 python -O source.py 即可将源程序编译为 pyo 文件。

## pyd

pyd 一般是 Python 外的其他语言如 C/C++ 编写的 Python 扩展模块，即 Python 的一个动态连接库，与 dll 文件相当。在Linux系统中一般为.so文件

# 常用的python解释器

Cython:C语言

Jython：java语言

IronPython：.net的

PyPy:python的

# 行连接符

> \

# 对象

> python中一切皆对象。每个对象由：标识（identity）、类型（type）、值（value）组成

1. 标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用`id(obj)`可返回对象obj的标识
2. 类型用于标识对象存储的“数据”的类型。类型可以限制对象在取值单位以及可执行的操作。可以使用`type(obj)`获得对象的所属类型
3. 值标识对象所存储的数据的信息。使用`print（obj）`可以直接打印出值

## 本质

**对象的本质就是： 一个内存块，拥有特定的值，支持特定类型的相关操作**

## 引用

> 在python中，变量也称为 ： 对象的引用，因为 变量存储的就是对象的地址

> 变量通过地址引用了对象

变量位于：栈    

对象位于：堆

## 注意：

1. python是动态类型语言

   变量不予要显式声明类型。根据变量引用的对象，Python解释器自动确定数据类型

2. python是强类型语言

   每个对象都有数据类型，只支持该类型支持的操作

# dir(对象)：获得所有的属性和方法

# print():输出

> 在调用print（）函数时，默认会调用str（）转换为字符串输出

1. print(输出内容):换行输出

2. print(输出内容,end='结束标志')

   `print('aa',end='')` => aa `不换行，接下来内容跟着他`

   `print('cc',end='**')`=>cc** `结束标志**，不换行`

3. print（“字符串1”，“字符串2”）  多个输出

4. print（‘’表达式：‘’，1+2）

5. 格式化打印：%d  %s  % f占位;【%d整数 ，%s字符串，%f浮点数】

   `%x --- hex 十六进制;  %d --- dec 十进制  %o --- oct 八进制`

   ```python
   print（“我今年%d岁，明年%f”%(20，21)）
   print（“我今年%d,.....%d”%（变量1,变量2））
   print（“%0.nf”%num）   保留n位
   ```

6. print(1,2,3,sep=":") :没个元素以：分割

7. ```python
   neme=“张立”；age=“18”；sex=“男”    
   print（“我的名字是：”name，“我的年龄是：”，age，“我的性别是：” ，sex）    
   print（“我的名字是%s，我的年龄是%d，我的性别是%s”%（name，age，sex））
   ```

## 参数

**print（* objects，sep =''，end ='\ n'，file = sys.stdout，flush = False ）**

将对象打印到文本流文件，以sep分隔，然后结束。 sep，end，file和flush（如果存在）必须作为关键字参数给出。

## 控制台输出颜色

```
\033开头[输出的方式;字体字,背景色+m+要设置的文本+\033[0m{"结尾可以省略,但是最好不要省略"}"

输出方式:0 默认;1 高亮;22 非粗体;4 下划线;24 非下划线;5 闪烁;25 非闪烁;7 反温;27 非反温
字体前景色:30 黑色;31 红色;32 绿色;33 黄色;34 蓝色;35 洋红;36 青色;37 白色
背景色:40 黑色;41 红色;42 绿色;43 黄色;44 蓝色;45 洋红;46 青色;47 白色
m:设置完成
```

### 例子

```python
print("\033[1;;47m"+str(x)+"\033[0m",end=" ")
```



# input():输入

**接收到的都是字符串**

## 提示信息

```python
input('请输入您的名字：')
```



# python的一些内置函数

## `round`（*编号*[，*ndigits* ] ）

小数点后舍入到*ndigits*精度的返回*数*。如果*ndigits*被省略或是，则返回其输入的最接近的整数。`None`	

## int('n',c):

```
n对应的c进制的10进制数
```

## abs()

1. 对于整数来讲，求一个数的绝对值

2. 对于复数（a+bJ）来讲，求 sqrt(a*a+b*b)

## isinstance('对象'，类型)

> 判断对象是否为某一类型，返回值为布尔值【True/False】

## `oct`（*x* ）:将整数转换为八进制字符串

将整数转换为前缀为“0o”的八进制字符串。结果是一个有效的Python表达式。如果*x*不是Python [`int`](https://docs.python.org/3/library/functions.html#int)对象，则必须定义一个[`__index__()`](https://docs.python.org/3/reference/datamodel.html#object.__index__)返回整数的方法。例如：

```python
>>> oct(8)
'0o10'
>>> oct(-56)
'-0o70'
如果要将整数转换为八进制字符串，或者使用前缀“0o”，则可以使用以下任一方法。
>>> '%#o' % 10, '%o' % 10
('0o12', '12')
>>> format(10, '#o'), format(10, 'o')
('0o12', '12')
>>> f'{10:#o}', f'{10:o}'
('0o12', '12')
```

## map(function，一个序列/多个序列)

> 返回一个map对象 ： <map object at 0x00F955B0>
>
> 映射

```python
map(function,可迭代的元素) =》python3返回一个迭代器；python2是列表
例子：
	def square(x):
        return x**2
	map(square,[1,2,3])   => 【1，4，9】
map(function,多个序列)=》多个列表长度不等，以短的为结束
	map(lambda x,y:x+y,[1,3,5],[2,4,6])  => [3,7,11]
```

## reduce函数

```python
from functools import reduce
reduce(函数，列表) =》前两个的结果作用到写一个
reduce(lambda x,y:x+y,list1)
```

## filter函数

```python
filter(函数/None,可迭代对象)  =》返回迭代器
 None=》返回迭代对象中为真的元素
filter(None,list1)
filter(lambda x:x!=0,list1)
```



## round(数，小数位数【可选参数】)

> 小数位数0有多个，只显示一个0
>
> 小数位数不传递，默认取证【四舍五入】

```python
round(80.2345,2)  => 80.23
round(100.000056,3)   => 100.0
round(-100.000056,3)   =>-100.0
```

## del（）：删除变量

> 由于python都是引用，而且python有GC机制，所以，del语句作用在变量上，而不在数据对象上

```python
a=1  #对象1被引用，对象1的引用计数器为1
b=a  #对象1被变量b引用，对象1的引用计数器+1
c=a  #对象1被变量c引用，对象1的引用计数器+1
del a   # 删除变量a，解除a对1的引用
del b   # 删除变量b，解除b对1的引用
```

```python
li=[1,2,3,4,5]   #列表本身不包含1.2.3等数据，而包含： li[0],li[1],....
first=li[0]
del li[0]   ===>> li=[2,3,4,5]
=====>   first=1
```

## sorted():对所有可迭代的对象进行排序操作

> sort 与 sorted的区别：
>
> sort是列表list上的方法，sorted可以对所有可迭代的对象进行排序操作
>
> sort返回的是对已经存在的列表进行操作，没有返回值
>
> sorted 返回的是一个新的list

```python
sorted(可迭代对象【，比较的函数【，用来进行比较的元素【，reverse=True(降序)/False(升序,默认)】】】)
比较的函数：具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为：大于返回1，小于返回-1，等于返回0
用来比较的元素：只有一个参数，具体的函数额参数取自于可迭代的对象中，指定可迭代对象中的一个元素进行排序

a=[5,7,6,3,4,1,2]
b=sorted(a)  => [1，2，3，4，5，6，7]

a=[5,7,6,3,4,1,2,-5,-3,-6]
b=sorted(a,k=lambda x:(x<0,abs(x)))  => [5,7,6,3,4,1,2,-3,-5,-6]

L=[('b',2),('a',1),('c',3),('d',4)]
sorted(L,cmp=lambda x,y:cmp(x[1],y[1])) #利用cmp函数
sorted(L,key=lambda x:x[1])  #利用key
[('a',1)，('b',2),('c',3),('d',4)]

student=[('john','A',15),('jane','B',12),('dave','B',10)]
sorted(student,key=lambda s:s[2]) #按年龄排序
[('dave','B',10),('jane','B',12)，('john','A',15)]

sorted(student,key=lambda s:s[2],reverse=True)  #降序

#字典=》指定key值
```

## range()函数:创建序列

```python
range（开始下标，结束下标，步进值）
取不到结束下标
```

## xrange（）：相当于生成器

```python
Xrange（start，stop [,step]）：根据start（开始值）、stop（结束值）和step（步长）的值他作为一个生成器，他生成的值是生成一个取出一个，而不是生成一个序列
Xrange比range的性能好，因为他不需要开辟一块大的空间去存储数据；
```



# 空格

> 缩进

# 注释:

> python中没有块注释，“”“ ”“”代表的是字符串  ； ‘’‘ ’‘’ 代表的是字符串

单行注释  #

"""   中的为注释内容"""

‘’‘  中的为注释内容  ’‘’

# 标识符

> 标识符用于变量、函数、类、模块等的名称

## 规则

1. 不能是关键字

   > 查看系统关键字：
   >
   > `>>>`help()
   >
   > `help>`keywords
   >
   > `False` `def` `if` `raise` `None` `del` `import` `return` `True` `elif` `in` `try` `and`  `else` `is` `while` `as` `except`  `lambda` `with`

2. 不能以数字开头，第一个字符必须是字母、下划线；其后可以跟字母、数字、下划线

3. 区分大小写，

4. 不能使用$符号

## 约定俗成的规则

1. 模块和包： 全小写字母，尽量简单。多个单词之间用下划线
2. 函数名: 全小写字母，多个单词之间用下划线隔开
3. 类名：首字母大写，采用驼峰命名原则。多个单词时，每个单词第一个字母大写，其余部分小写
4. 常量名：全大写字母，多个单词使用下划线隔开

# 变量和简单的赋值语句

1. 不用声明，直接赋值（极简）

   > 先赋值再引用

```python
num = 123
说明： 运行过程中，解释器先运行右边的表达式，生成一个代表表达式运算结果的对象，然后，将这个对象地址复制给左边的变量
```

2. 变量可以存储不同的数据类型
3. 可以同时为多个变量赋值

```css
a,b=123,456
```

4. 不支持自增自减   但可以：a+=1
5. 变量名不可以是关键字和保留字

## 删除变量

> 可以通过del语句删除不再使用的变量
>
> `del a`

## 垃圾回收（GC机制）

> 如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间
>
> 维护引用计数内存

1. 引用计数为主:初始化引用计数为2

   * 增加引用计数

     * 有新对象使用该对象 +1
     * 装进列表 +1
     * 作为函数参数 +1

   * 减少引用计数

     * 新的对象不在使用-1
     * 从列表移除-1
     * 函数调用结束-1
     * del 函数

   * 获取引用计数

     ```python
     import sys
     sys.getrefcount(a)
     ```

   ```python
   class AA():
       # 创建对象开辟内存时调用
       def __new__(cls,**args,**kwargs):
           print('开辟内存空间')
           return super(AA,cls).__new__(cls)
       # 初始化方法
       def __init__(self):
           print('创建对象at:'+%hex(id(self)))
           
       # 对象被系统回收之前调用的方法
       def __del__(self):
           print(hex(id(self))+' say bye bye')
   ```

2. 隔代回收为辅助

> 解决相互引用
>
> 随着时间的推进，程序冗余对象逐渐增多，达到一定数量（阈值），系统进行回收
>
> ( 0/1/2)代

```python
import gc
gc.get_count()  =》( 0/1/2)代
gc.get_threshold()  =》阈值
gc.set_threshold()  =>修改
```



## 链式赋值

> 链式赋值用于一个对象赋值给多个变量

x=y=123;  相当于   ： x=123;y=123

## 系列解包赋值

> 系列数据赋值给对应相同个数的变量（个数必须保持一致）

a,b,c=4,5,6   相当于： a=4;b=5;c=6

用于变量交换

```python
a,b=10,20
a,b=b,a
```

## 常量

> ** python不支持常量  **

## 变量的引用规则

```python
a)相同的值（数值），python会进行内存地址的引用（节省内存，共享数据）
b)通过id（ ）函数查看内存地址
c)通过sys.getrefcount 查看引用次数
d)通过 del（）删除地址引用
数值和字母可以引用同一个地址→数据共享
汉字字符串不能引用同一个地址
Num=20；num1=Num   地址相同
Str=“张三”
Str1=“张三”    地址不同
```

# 数据类型

## 数值型

### 整数

```python
整数（int） 浮点数（float）复数【complex】（虚部以j或者J结尾）                         二进制     num=0b或者0B开头   
八进制     num=0o或者0O开头   
十六进制   num=0x或者0X开头

科学计数法num=8e2(8*10^2)                                                 
转换为浮点数   float(num)

将十进制转换为二进制(   bin(  )  )，八进制(   oct( )    )，十六进制(   hex( )   )
```

**使用`int()`实现类型转换**

1. 浮点数直接舍去小数部分
2. 布尔值： True =》1；False=》 0
3. 字符串符合整数格式（浮点数不行），则直接转换成对应整数，否则不行

**整数可以有多大**

1. 在Python2中，int是32位，可以存储-2^31 到 2^31-1；Long类型是64位，可以存储 -2^61到2^61-1之间的数值
2. 在python3中，int可以存储任意大小的整数，long被取消
3. python3中可以做超大数的计算，而不会造成 ‘整数溢出’，这也是python特别适合科学运算的特点

#### 整数缓存问题

`python仅仅对比较小的整数对象进行缓存（范围是[-5,256]）,而并非所有整数对象。但需要注意的是，这仅仅是在命令行中执行，而在Pycharm或者保存为文件执行时，结果是不一样的，这是因为解释器做了一部分优化（范围是[-5,任意正整数]）`

### 浮点数

> 称为float
>
> 浮点数用a×b^n形式的科学计数法；例如： 3.14 =》314E-2或者314e-2

```python
转换为整数 int(num) 
```

#### float(num)：将num转换为float型

> 运算完生成新的对象

#### round(num):返回四舍五入的值

> 不会改变原有值，而是生成新的值

#### round(num，n):对num保留n位小数

> 不会改变原有值，而是生成新的值

### 数字格式化

> 浮点数：f；整数：d

```python
a='我是｛0｝，我的存款有｛1:.2f｝'
a.format('杨国璇',9999.99999)
结果：我是杨国璇，我的存款有9999.99
```

| 数字       | 格式     | 输出      | 描述                            |
| ---------- | -------- | --------- | ------------------------------- |
| 3.1415926  | {:.2f}   | 3.14      | 保留小数点后两位                |
| 3.1415926  | {:+0.2f} | 3.14      | 带符号保留小数点后两位          |
| 2.71828    | {:.0f}   | 3         | 不带小数                        |
| 5          | {:0>2d}  | 5         | 数字补零（填充最左边，宽度为2） |
| 5          | {:x<4d}  | 5xxx      | 数字补x（填充最右边,宽度是4）   |
| 10         | {:x<4d}  | 10xx      | 数字补x（填充最右边,宽度是4）   |
| 1000000    | {:,}     | 1,000,000 | 以逗号分隔的数字格式            |
| 0.25       | {:.2%}   | 25.00%    | 百分比格式                      |
| 1000000000 | {:.2e}   | 1.00e+09  | 指数计数法                      |
| 13         | {:10d}   | 13        | 右对齐（宽度10）                |
| 13         | {:<10d}  | 13        | 左对齐（宽度10）                |
| 13         | {:^10d}  | 13        | 中间对齐（宽度10）              |

## 布尔型

1. python2中没有布尔值，直接用数字0表示False，用1表示True

2. python3中，把True和False定义成了关键字，但他们的本质还是1和0，甚至可以和数字相加

   ```python
   a=True
   b=3
   c=a+b  =>  4
   ```

## 字符串

### 本质

> 字符序列
>
> intern机制：每个单词（字符串），不夹杂空格或者其他符号，默认开启intern机制；引用计数

**python的字符串是不可变的，我们无法对原字符串做任何修改，但是可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果**

> python不支持单字符类型，单字符类型也是作为一个字符串使用的

### 编码

> python3直接支持Unicode，可以表示世界上任何书面语言的字符。python3的字符默认就是16位Unicode编码，ASCII码是Unicode编码的子集 ： ASCII=》（2^8）;Unicode =》 （2^16）

#### ord("字符")

> 将字符转换为对应的Unicode码

#### chr(num)

> 将十进制数num转换为对应的字符

```python
chr(ord('字母/字符')+n)
从字母/字符对应的Unicode码开始的后第n个元素
```

### 创建

#### 单行

> 单引号/双引号
>
> 内容有引号；用`‘ ’`或者`"  "`包含
>
> 原始字符串：a=r'ads：爱的速递\\sads \'

#### 多行

`'''字符串（可以有引号）'''`或者`"""  """`

### 空字符串

`c=''`不包含任何字符

### 转义字符

> 我们可以用`\+特殊字符`实现默写难以用字符表示的效果，比如换行等

| 转义字符  | 含义              |
| --------- | ----------------- |
| \(在行尾) | 续行符            |
| \\        | 反斜杠符号        |
| \'        | 单引号            |
| \"        | 双引号            |
| \b        | 退格（Backspace） |
| \n        | 换行              |
| \t        | 横向制表符        |
| \r        | 回车              |

```python
转义字符：                                                                                 前缀  r：代表后面字符串是普通字符串     r"\n\t\b"  相当于每个进行转义                             前缀  b : 代表后面的字符串是byte数据，在python2中print函数操作的字符串全部是byte数据，在Python3中操作的是unicode数据                                                                             前缀  u: 主要是python2为了兼容python3，后面数据为unicode数据   
```

### 原生字符串

```python
str1=r'字符串'
```



### 字符串拼接

> 生成新对象

1. 使用`+`：例如：'a'+'b'==> 'ab'

   a. 如果`+`两边是字符串，则是拼接

   b. 如果`+`两边是数字，就是加法运算

   c. 如果`+`两边类型不同，则抛出异常

2. 可以将多个字面字符串直接放到一起实现拼接

   例如：‘aa’‘bc’   ===> ‘aabc’

### 字符串的复制

`例子`a='ss'*3   ===>> 'ssssss'

### str():将其他转换为字符串

```python
str(3.14e2) => '314.0'   str(True) => 'True'   
```

### 字符串切片

**正向搜索：**最左侧第一个字符，偏移量是`0`，第二个偏移量是`1`，依次类推，直到`len(str)-1`为止

**反向搜索：**最右侧第一个字符，偏移量是`-1`，第二个偏移量是`-2`，依次类推，直到`-len(str)`为止

```python
str1[起始偏移量：终止偏移量：步长step]不包括终止偏移量 
Str[0]:取出字符串str的第一个字符
切片取多个： 
str[0:-1]   =>  不取最后一个
Str[0:2]         从0个开始，取2个 
Str[2:4]         从第2个开始，取  4-2=2  个步长：
Str[0：:1]         从0个开始，每隔1-1=0 步取一个	 
Str[0：：2]         从0个开始，每隔2-1=1 步取一个
Str[-3:]  倒数三个
Str[-8:-3]  倒数第八个到倒数第三个（不包括倒数第三个）
Str[::-1]   逆序【反向截取】

# 起始偏移量和终止偏移量不在0-len(Str)之间，大于则取长度，小于取到0
```

### 字符串的替换：replace（）

```python
str1.replace（‘a’，‘aa’）   # 将a替换为aa
```

**创建了新的字符串对象，并指向了变量str1，而不是修改以前的str1**

### split（）分割和join（）合并

**`split（）`可以基于指定分割符将字符串分割成多个子串（存储到列表中）**如果不指定分割符，默认使用空白符（换行符/空格/制表符）

```python
字符串.split（“分隔符”，num）将字符串通过分割符进行分割，num指定分割次数
```

`"连接符".join(列表)`将列表对象用分隔符组合为字符串

```python
“分隔符”.join（列表） 将列表对象用分隔符组合为字符串
```

### 两种字符串拼接的比较

1. str+='字符串'   ： 耗时耗力，因为每次都会开辟新的空间（字符串不可变）
2. join（） ： 利用列表可变的性质，省时省力

### 字符串驻留机制

**仅保存保存一份相同且不可变字符串的方法，不同的值呗存放在字符串驻留池中，Python支持字符串驻留机制，对于`符合标识符规则的字符串（仅包含下划线、字母、数字）`会启用字符串驻留机制**

### 字符串和整数的相互转换

#### 字符串转换成数字

1. 方法一

   ```python
   类中进行导入：import string
   str='555'
   num=string.atoi(str)
   num即为str转换成的数字
   
   转换为浮点数：string.atof(str)
   ```

2. 方法二

   ```python
   直接int
   int(str)即可。
   ```

#### 数字转换为字符串

```python
num=322
str1='%d'%num
str1=str(num)
```

### 查找

> 产生新字符串

1. `字符串.find("查找内容"，开始位置，结束位置)`   没有返回-1，有返回下标（第一次出现的位置）
2. `字符串.rfind("查找内容"，开始位置，结束位置)`  从右边开始找（最后一次出现的位置）
3. 字符串.index("查找内容"，开始位置，结束位置)   没有报异常，有返回下标
4. 字符串.rindex("查找内容"，开始位置，结束位置)   没有报异常，有返回下标
5. `字符串.endswith（“结尾的元素”）`是否以某一个字符结尾
6. `字符串.startswith（“开始的元素”）`是否以某一个字符开始
7. `字符串.count(‘元素’)`元素出现的次数
8. `字符串.isalpha（）`至少一个字符，并且所有字符都是字母

### 去除首尾信息

> 产生新字符串

1. 字符串.strip('去除首尾的东西')  在字符串前后删除空格，或者删除str('去除首尾的东西') 
2. 字符串.lstrip('去除首部的东西')
3. 字符串.rstrip('去除尾部的东西')

### 大小写转换

> 产生新字符串

1. 字符串.capitalize()   把字符串的首字母大写
2. 字符串.title()   每个单词的首字母大写
3. 字符串.upper（）大写
4. 字符串.lower（）  小写
5. 字符串.swapcase()   所有字母大小写转换

### 格式排版(字符串扩充)

> 不写填充符，默认是空格

1.  字符串.center（len，“填充符”）以字符串为中心扩充
2. 字符串.ljust(len,“填充符”)     字符串在左
3. 字符串.rjust(len,“填充符”)   字符串在右

### 字符串其他内建函数

1. 编码

   ```python
   字符串.encode（encoding=“gb2312”，errors=“ignore”） 
       encoding=“编码方式”，errors=“错误忽略”
   ```

2. 解码

   ```python
   字符串.decode（encoding=“gb2312”，errors=“ignore”）
   ```

3. `字符串.isalnum（）`至少一个字符，并且所有字符都是数字字母

4. `字符串.isalpha（）`至少一个字符，并且所有字符都是字母[含汉字]

5. `字符串.isdigit（）`字符串是否都是数字

6. `字符串.isspace（）`至少为一个字符，并且字符串全为空白符，返回True，否则返回False

7. `字符串.isupper（）`字符串是否都是大写

8. `字符串.islower（）`字符串是否都是小写

9. `字符串.isdecimal（）`字符串是否都是十进制的数字

10. `字符串.splitlines（）`将字符串通过\n进行分割

### 字符串格式化format()

**两种不能交叉使用**

1. 下标索引

```python
a="名字是：{0}，年龄是：{1}"
a.format('杨国璇',18) 
# 通过索引填充不同的字符串，可以通过下标索引多次引用
```

2. 关键字

```python
a="名字是：{name}，年龄是: ｛age｝"
a.format(age=18,name="杨国璇")
# 通过关键字填充不同的字符串，可以通过关键字多次引用
```

3. 填充与对齐

```python
^、<、> 分别是居中、左对齐、欲对其、后面带长度（宽度）
:  号后面带填充字符，只能是一个字符，不指定的话默认使用空格填充
    
a='{:*>8}'
a.format('245')

b="名字是：{0}，喜欢的数字是: ｛1：*^8｝"
b.format('杨国璇','666')
结果：'名字是：杨国璇，喜欢的数字是：**666***'
```

### 可变字符串

**在python中，字符串是不可变对象，不支持原地修改**要想修改，使用`io.StringIO对象或者array模块`

```python
import io
s='ygxLovedxn'
sio=io.StringIO(s)
sio.getvalue()  获取值
sio.seek(7)  => 指针移动到索引为7的位置
sio.write('ll')   =》 在指针位置写值
sio.getvalue()
```

### 字符串比较大小

```python
name="ygx"
name=name.encode("utf8")
int.from_bytes(name,byteorder="big")
```



## 列表

> 一种数据存储方式，用来存储一系列的数据
>
> 在内存中，序列就是一块用来存放多个值的连续的内存空间
>
> 存的是对象的地址

**列表大小可变，根据需要随时增加或者缩小**

**可以存储任何类型的数据**

**通过索引下标`0-len（）-1`获取**

### 列表的创建

1. a=[10,20,'ygx','love']
2. list()方法

```python
a=list(range(10))  => [0,1,2,3,4,5,6,7,8,9]
a=list('ygx,love') => ['y','g','x',',','l','o','v','e']
```

3. range()创见整数列表

```python
range([start,] end [,step])
返回range对象
```

4. 推导式

```python
a=[x for x in range(10) if x%2==0] #if过滤符合条件的
```

### 列表元素的添加

**当列表增加和删除元素时，列表会自动进行内存管理；**但这个特点涉及到列表元素的大量移动，效率低，除非必要；**我们一般只在列表的尾部添加/删除元素，这会大大提高列表的操作效率**

1. `list1.append()` 原地址修改列表对象，是真正的表尾添加新的元素，速度最快，推荐使用

2. `+`产生新的列表对象（地址变），大量是不要使用，耗内存

   ```python
   合并多个 ：  列表1+列表2+列表3  ；  列表1+=列表2+列表3
   ```

3. `list1.extend()`原地址操作，添加到列表尾部(两个列表)

   ```python
   a=[20,40]
   a.extend([50,60])
   ```

4. `list1.insert()`将指定元素插入到列表对象的任意指定的位置；会让插入位置后打所有元素进行一定，会影响处理速度，涉及到大量元素时，尽量避免使用。**使元素移动的函数还有`remove()` `pop()` `del()`

5. *乘法扩展

### 列表元素的删除

1. `del` 删除 ：删除列表指定位置的元素

   ```python
   del a[位置]
   ```

2. `pop()`删除并返回指定位置的元素，如果未指定位置，默认是列表最后一个元素

3. `remove()`删除首次出现的指定元素，若不存在，则抛出异常

### 列表元素的访问和计数

1. 通过索引直接访问元素

2. `index()`获得指定元素在列表中**首次**出现的索引

   ```python
   list1.index(value[,start [ , end]])
   start和end指定了搜索范围
   ```

3. `count()`获得指定元素在列表中出现的次数

4. `len()`返回列表长度

### 成员资格的判断

1. `count()`
2. 元素 in 列表

### 切片操作

**格式**       list1[起始偏移量 : 终止偏移量[ : 步长 ] ]

操作同字符串

* 起始偏移量和终止偏移量不在0-len(Str)之间，大于则取长度，小于取到0

#### 特殊情况

```python
特殊情况：
    x=[3,5,7]     
    1. x[1:]=[2]  x=>[3,2]
    2. x[:3]=[2]   x=>[2]
    3.x=[1,2,3]    x[2:]=[4,5,6]  x==>> [1,2,4,5,6]
    4. 已知x=[3,5,7],那么表达式x[10:]的值为：  []
    5. x=[1,10,3]
    	x[len(x):]=[1,2]
    	x=[1,10,3,1,2]

```

### 列表的遍历

1. for i in 列表

   ```python
   for i in 列表名：
   	print（i，end="  "）     i 代表内容
   	print（列表.index（i）） 遍历下标【当有两个元素重复出现的时候，默认下标是第一次出现的元素的标】
   ```

2. for index,value in enumerate(列表)

   > enumerate(列表名): 将列表转换为（（index，value），（index，value））的序列

   ```python
   for index,value in enumerate(列表名):
       print(index,value)       inedx下标，value值
   ```

### 列表的排序

1.  `list1.sort()` 修改原列表，不新建列表

   参数：reverse=True ：降序排列

   ​	    默认升序

   ```python
   def takeSecond(ele):
           return ele[1]
       radom=[(2,2),(3,4),(4,1),(1,3)]
       radom.sort(key=takeSecond , reverse=False)
       random=[(4,1),(2,2),(1,3),(3,4)]
   ```

2. `random.shuffle() ` 随机排序，修改原列表

   ```python
   import random
   random.shuffle(list1)   #打乱顺序
   ```

3. `sorted()` 生成新的列表对象

   ```python
   a=sorted(list1)  #默认升序
   a=sorted(list1，reverse=True)  #降序
   ```

### 逆序排列

`reversed()`返回一个逆序排列的迭代器对象

```python
c=reversed(list1)
```

### 列表的其他内建函数

```python
1. 列表.copy（） 浅拷贝
2. 列表.clear（） 清空列表
3. zip(arr,arr1)  将两个数组粘合起来
    x = [1, 2, 3]
    y = [4, 5, 6]
    zipped = zip(x, y)
    list(zipped)    =》   [(1, 4), (2, 5), (3, 6)]
    
    zip()与*运算符一起使用可以解压列表
    x2, y2 = zip(*zip(x, y))
    x2=(1, 2, 3)，y2=(4, 5, 6)
    x == list(x2) and y == list(y2) =》True
    
4. dict(二维数组)  变成字典
```

### 二维列表（数组）

```python
[[1,2,3],[4,5,6]]
```

访问： list1[行]****[ 列]

### 二维数组变一维

```python
l=[[1,2,3],[4,5,6],[7,8,9]]

c=[i for item in l for i in item]
d=eval('['+str(l).replace(' ','').replace('[','').replace(']','')+']')

print(c)
print(d)
```

## 元组tuple

**元组是不可变的，不能修改元组中的元素，因此元组没有增加、删除、修改元素的相关方法**

### 创建

1. `()`创建

   ```python
   a=(10,20,30)   <=>  a=10,20,30
   
   # 一个元素
   a=(10,)    <=>a=10,
   
   mytuple=（[1,2,3]，[4,5,6]）
   ```

2. `tuple()`创建

   ```python
   tuple('abc')
   tuple(range(3))
   tuple([2,3,4])
   ```

   **tuple()可以接受列表、字符串、其他序列、迭代器生成元组**

   **list()可以接受元组、字符串、其他序列、迭代器生成列表**

3. 推导式

   ```python
   s=(x*2 for x in range(10) if x%2==0)
   tuple(s)
   ```

**注意**

```python
元组和列表有些类似，区别就是元组指针不可改变
元组通过圆括号定义
可以使用切片
元组可以定义只有一个元素的元组，mytuple=（1，），逗号必不可少
可以定义空元组
```

### 元组的元素访问和计数

1. 元组的元素不能修改
2. 通过索引和切片访问，返回仍是元组
3. 对元组排序，只能用sorted（元组）并声称新的列表对象

### zip

```python
zip(list1，list2，list3....)
# 将多个列表对应位置的元素组合成为元组，并返回这个zip对象
经常用list(zip对象)来使用其中的元素

list(map(list,zip(*[[1,2,3],[4,5,6]])))  => [[1, 4], [2, 5], [3, 6]]  解构
```

### 内建函数

```python
len（）
max()
min()
list()   将元祖转换为列表
tuple()   将列表转换为元组
enumerate() 返回下标和元素
```

## 字典

> 字典是“键值对”的无序可变序列。
>
> 字典中的每一个元素都是一个“键值对”，包含：“键对象”和“值对象”，可以通过“键对象”实现获取、删除、更新对应的‘值对象’

**键是任意不可变数据，如`整数、浮点数、字符串、元组`但是`列表、字典、集合`是可变对象（可以被哈希hash()），不能作为“键”，并且`“键”不可重复,但是‘值’可以重复

空间换时间

### 创建

1. {"name":"ygx","age":24,"sex":"男"}

2. dict(name="ygx",age=18,sex="男")

3. dict([("name","ygx"),("age",18)])

4. 空字典对象 `c={}`

5. 空字典对象 `d=dict()`

6. zip()创建

   ```python
   k=['name','age','sex']
   v=['ygx',18,'男']
   d=dict(zip(k,v))    ==>>  ｛"name":"ygx","age":18,"sex":"男"｝ 
   ```

7. 通过fromkeys创建值为空的字典

   ```python
   a=dict.fromkeys(['name','age','sex'])  ==>> {"name":None,"age":None,"sex":None}
   b=dict.formkeys([“name1”，“name2”]，“a”)
   ```

### 字典元素的访问

> `mydict={"name":"ygx","age":18;"sex":"男"}`

1. `mydict['键']`   不存在，抛出异常

2. `mydict.get('键' [,"info"])`返回key对应的value,没有为none，info指定没有找到的提示语言

3. `mydict.items()`  获得所有的键值对；

   ```python
   # 返回
   [('name'，'ygx'),()..]
   ```

4. `mydict.keys()`列出所有的键

5. `mydict.values()`列出所有的值

6. `len()`键值对的个数

7. `'键' in mydict`检测一个键是否在字典中

### 字典元素的添加、修改、删除

1. 添加 

   **没有添加，有覆盖**

   ```python
   mydict['address']="内容"
   ```

2. 使用`update()`将新字典中所有键值对全部添加到旧字典对象上，如果key有重复，则直接覆盖

   ```python
   a={"name":"ygx","age":18}
   b={"name":"dxn","sex":"女"}
   a.update(b)
   a={"name":"dxn","age":18,"sex":"女"}
   ```

3. 删除

   1. `del()` **del（mydict['键']）**
   2. `clear()`删除所有的键值对**mydict.clear()**
   3. `pop()`**mydict.pop("键")；返回键的值**
   4. `popitem()`随机删除和返回该键值对（字典无序）**mydict.popitem()**

4. `mydict.setdefault（key，value）`   添加数据

### 字典的核心底层

> 　字典对象的核心是散列表，散列表是一个系数数组（总有空白元素的数组），数组的每个单元就叫做｀ｂｕｃｋｅｔ｀。每个ｂｕｃｋｅｔ有两个部分：一个是键对象的引用，一个是值对象的引用

**由于所有的ｂｕｃｋｅｔ结构和大小一致，我们可以通过偏移量来读取指定的ｂｕｃｋｅｔ**

1. bin(hash('键')) **==》存**

   1. 取右边三位，看bucket（桶）内是否有元素，没有，将键值对放进去；有，再去其前边的三位，看桶内是否有元素
   2. 如果发现桶满了2/3，仍有元素没放进去，将桶扩容，在放

2. bin(hash('键')) **==》取**

   和存类似

## 集合

> 无序可变，元素不能重复
>
> 集合的底层是键

### 创建和删除

1. `｛｝`创建，使用add()方法添加元素

   ```python
   myset.add("abc")   #abc只认为是一项 ，认为是整体
   myset.update("def")   #def认为是三项，认为是一个新集合推送进去
   ```

2. 使用`set()`将列表、元组等可迭代对象转换为集合（唯一性）

   ```python
   myset=set('abcde')
   meyset=set([1,2,3,4,5])
   myset=set('字符串')
   ```

3. `remove()`删除指定元素，`clear()`清空整个集合

   ```python
   myset.remove("abc")
   ```

### 相互转换

```python
mylist=[1,2,3,4,5,6]
set（list）  转换为集合
list（set（list） ） 转换为列表
```

### 集合的操作

1. `-` 差集

2. `|`  并集

3. `&`  交集

4. 判断C是A的真子集？

   ```python
   set(A) > set(C) 
   ```

## 序列解包

1. 序列解包可以用于元组、列表、字典

   ```python
   x,y,z=(20,30,10)
   (a,b,c)=(9,8,10)
   [a,b,c]=[10,20,30]
   ```

2. 字典

   ```python
   mydict={"name":"ygx","age":18;"sex":"男"}
   name,age,sex=mydict   # 默认对键进行操作
   name,age,sex=mydict.items()  #对键值操作
   name,age,job=mydict.values()  #对值进行操作
   
   ```


## 元组、字典、列表的比较

1. 元组不可变，字典、列表可变

2. 元组的访问和处理速度比列表快

3. 与整数和字符串一样，`元组可以作为字典的键`，列表则永远不能作为字典的键

4. 数组内容可以被修改，而元祖内容是只读的，不可被修改的，另外元祖可以被哈希，比如作为字典的key

   

# 正则

## 基础语法

### 语法格式

| 字符 | 功能                          |
| ---- | ----------------------------- |
| .    | 匹配任意一个字符（除了\n）    |
| []   | 匹配列表中的字符 任意一个     |
| \d   | 匹配数字0-9                   |
| \D   | 匹配非数字                    |
| \s   | 匹配空格（\n、\t、`  `）      |
| \S   | 匹配非空格                    |
| \w   | 匹配单词字符，即a-z,A-Z,0-9,_ |
| \W   | 匹配非单词字符                |

```python
re.match('.','a')
```

### 表示数量

| 字符  | 功能                                                       |
| ----- | ---------------------------------------------------------- |
| *     | 匹配前一个字符出现0次或者无限次（可有可无）                |
| +     | 匹配前一个字符出现1次或者无限次（至少一次）                |
| ？    | 匹配前一个字符串出现1次或者0次（要么一次要么没有）(非贪婪) |
| {m}   | 匹配前一个字符出现m次                                      |
| {m,}  | 匹配前一个字符至少出现m次                                  |
| {m,n} | 匹配前一个字符出现m到n次                                   |

#### 例子

1. 第一个是大写，其余小写

   ```python
   '[A-Z][a-z]*'
   ```

2. 有效的变量名,数字不能开头

   ```python
   '[A-Za-z_][A-Za-z0-9_]*'
   '[A-Za-z_]\w?'
   ```

3. 匹配1-99之间的数字

   ```python
   '[1-9][0-9]?'
   ```

4. 匹配随机密码8-20位

   ```python
   '\w{8,20}'
   ```

### 原生字符串

```python
str1='\\n123654'
str1=r'\n123654'
匹配规则：
	'\\\\n123456'
    r'\\n123456'
```

### 边界

| 字符 | 功能               |
| ---- | ------------------ |
| ^    | 匹配字符串的开头   |
| $    | 匹配字符串的结尾   |
| \b   | 匹配一个单词的边界 |
| \B   | 匹配非单词的边界   |

### 匹配分组

| 字符       | 功能                             |
| ---------- | -------------------------------- |
| \|         | 匹配左右任意一个表达式           |
| (ab)       | 将括号中的字符作为一个分组       |
| \num       | 引用分组num‘匹配到的字符串       |
| (?p<name>) | 分别起组名                       |
| (?p=name)  | 引用别名为name分组匹配到的字符串 |

#### 匹配座机号

```python
区号(3-4)-电话号(7)
p=r'(\d{3,4})-([1-9]\d{6}$)'
# v.group(1)
# v.groups()[0]
```

#### html标签

```python
p=r'<(.+)><(.+)>.+</\2></\1>'
p=r'<(?p<key1>.+)><(?p<key2>.+)>.+</(?p=key2)></(?p=key1)>'
```

## re模块



### re.match从头开始匹配

> 匹配成功返回一个匹配的对象，否则返回None
>
> re.match(正则表达式，‘要匹配的字符串’，flags=0)

#### 参数说明：

```python
flags: 标志位，用于控制正则表达式的匹配方式，如： 是否区分大小写，多行匹配等，
```

#### 例子:

```python
import re
re.match('www','www.adc.com').span()   => 在起始位置匹配    =》  结果  （0,3）
re.match('com','www.adc.com')   => 不在起始位置匹配   =》  结果  None
```

### group（[num=0]）

> 方法：匹配对象函数来获取匹配表达式

| 匹配对象的方法 |                             描述                             |
| :------------: | :----------------------------------------------------------: |
|  group(num=0)  | 匹配的整个表达式的字符串，group（）可以一次输入多个组号，在这种情况下他将返回一个包含那些组所对应值的元组 |
|    group()     |     返回一个包含所有小组字符串的元组，从一到所含的小组号     |

#### 例子

```python
import re
line='Cats are smarter than dogs'
matchObj=re.match(r'(.*) are (.*)? .*',line,re.M|re.I)

if matchObj:
    print('matchObj.group():',matchObj.group())       =》   Cats are smarter than dogs 
    print('matchObj.group():',matchObj.group(1))      =》   Cats
    print('matchObj.group():',matchObj.group(2))	  =》   smarter
 else:
    print('无匹配项')
```

### re.search全部找

> re.search(正则表达式，要匹配的字符串，flags=0)

> 匹配成功返回一个匹配的对象，否则返回None
>
> 只找匹配到的第一个

#### 例子

```python
import re
re.match('www','www.adc.com').span()   => 在起始位置匹配    =》  结果  （0,3）
re.match('com','www.adc.com').span()   => 不在起始位置匹配   =》  结果  (8,11)
```

### re.match()和re.search（）的区别

> re.match() 只匹配字符串对的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None
>
> research() 匹配整个字符串，直到找到第一个匹配

### 检索和替换 （re.sub（））

```python
re.sub(正则，替换的字符串，要被查找的原始字符串，count=0，flags=0)

count：匹配模式后替换的最大次数，默认0表示替换所有的匹配
返回新的替换后的字符串
```

#### 例子

```python
import re
phone='183-3521-9360 # 这是一国外的手机号'

# 删除 # 后面的字符串
re.sub(r'#.*$','',phone)

# 保留数字（删除非数字部分）
re.sub(r'\D','',phone)
```

#### 注意：当  替换的字符串 示函数时

```python
import re
# 将匹配的数字乘以2
def double（matched）：
	value=int(match.group('value'))
    return str(value*2)

s='A23G4HDF856'
re.sub('(?P<value>\d+)',double,s)    =>   A46G8HDF1712
```

### re.compile():编译正则表达式，生成正则表达式对象

> 供  match（） 和  research（）使用





### re.findall

> 从左到右扫描字符串，并按照找到的顺序返回匹配
>
> 如果有一个或多个组，返回列表

```python
re.findall(r'\d+','字符串')
```

### re.finditer

> 在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。

```python
re.finditer('正则','字符串','标志位')
标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。
```



### re.split

> 拆分

```python
p=r'\s|:|,'

```

## 正则表达式修饰符 - 可选标志

正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：

| 修饰符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| re.I   | 使匹配对大小写不敏感                                         |
| re.L   | 做本地化识别（locale-aware）匹配                             |
| re.M   | 多行匹配，影响 ^ 和 $                                        |
| re.S   | 使 . 匹配包括换行在内的所有字符                              |
| re.U   | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.      |
| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |

## 中文

`[\u4e00-\u9fa5]+`
`[\u4e00-\u9fa5]+\w+`

# 深拷贝、浅拷贝

> import copy   #导包
>
> copy.copy()、copy.deepcopy()

## 浅拷贝

**不拷贝子对象的内容，只拷贝子对象的引用**

![](E:\Git\笔记大全\PyThon\基础知识\深拷贝.jpg)

## 深拷贝

**会连子对象的内存也全拷贝一份，对子对象的修改不会影响源对象**

![](E:\Git\笔记大全\PyThon\基础知识\深拷贝.jpg)

# 迭代器和生成器

## 迭代对象

> 字符串 列表 字典 集合

## 迭代器(iterator)

> 需要循环的时候在进行遍历（循环） =》 迭代对象（字符串 列表 字典 集合 元组）=》节省内存，提高效率
>
> 作用： 生成迭代对象

**语法**

```python
最简单： a=iter("abc")

next（a）  =》 a
next（a）  =》 b
...

#复杂1：
class myiter:
    def __init__(self,data):
        self.data=data
        self.length=len(data)
        self.start=-1
   	def __iter__(self):
    	return self
	def next(self):
       	# 自己定义想输出的规则
        return **

#复杂2：  
from col.. import StopIteration
class aa:
    def __init__(self):
        self.datas=["a","b"]
        self.index=0
    def __iner__(self):
        return self
    def __next__(self):
        if self.index<len(self.datas):
            print(self.datas[self.index])
            self.index+=1
            return self.datas[self.index])
        else:
            raise StopIteration    
    
```

迭代器是一个更抽象的概念，任何对如果它类有 next 方法和 iter 方法返回自己本身 。对于 strings、list、dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句 对容器象调用 iter()函数，iter()是 python 的内置函数。iter() 会返回一个定义 next()方法的迭代器对象，它在容器中逐个访问容 器内元素， next()也是 python 的内置函数。在没有后续元素时， next()会 抛出一个 StopIter 异常 



## 生成器（generator）

生成器（ Generator）是创建迭代器的简单而强大工具。 它们写起来就像是正规的函数，只在需要返回据时候使用 yield 语 句。每次 next()被调用，生成器会返回它脱离的位置，记忆语句最 后一次执行和所有数据。

> 将函数的返回的内容,装进生成器对象里面
>
> **一种特殊的迭代器（更轻松的生成迭代对象） **
>
> 记录个算法，一边便利，一边计算的一种机制

```python
yield 把函数生成一个迭代器  
用的时候转换为列表等
yield 等待next的调用

写法一：
	a=（item for item in range(10)）
    调用 next(a)
    for i in a:
        i:每个数据
写法二：
	#def a:
	#	yield "a"
    def aa():
        for item in range(1000):
            yield item
    for i in aa():
        print(i)        
```

## 区别

生成器能做到迭代的所有事 ,而且因为自动创建了 __iter__()和 next()方法 ,生成器显得特别简洁 ,而且生成器也是 高效的 ，使用生成器表 达式取代列解析可以同时节省 内存。除了 创建和保程序状态的自动方法,当发生器终结时 ,还会自动抛出 StopIteration 异常。 

## 什么是yield

简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次（或n 次）调用跳转至该函 次）调用跳转至该函 数



# 推导式总结

## 列表推导式

1. 列表推导式其形式是用方括号括起来的一段语句,是一种快速生成列表的方式

```
循环1-10的数字，并且将每一个数字平方：
推导式写法:
lis = [x * x for x in range(1, 10)]
正常循环写法:
lis=[]
for x in range(1,10):
    lis.append(x*x)

print(lis)
------------------------------------
结果：[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

2. 列表推导条件语句用法

```
循环1-10的数字，取得偶数并且将每一个数字平方
推导式写法:
lis=[x * x for x in range(1, 11) if x % 2 == 0]
正常循环写法:
lis=[]
for x in range(1,10):
    if (x%2==0):
        lis.append(x*x)
print(lis)
-----------------------
[4, 16, 36, 64, 100]
```

3. 双层循环

```python
x=[j for i in [[1,2,3],[4,5,6]] for j in i]
x===>[1,2,3,4,5,6]
```



## 字典推导式

> 使用中括号[]可以编写列表推导式，那么使用大括号{}可以制造字典推导式！

```
dic = {x: x**2 for x in (2, 4, 6)}
print(dic)
-------------------------
{2: 4, 4: 16, 6: 36}

print(type(dic))
------------------------
<class 'dict'>

```

**
注意：x: x**2的写法，中间的冒号，表示最终生成的字典结构，左边的是key右边的是value
**

## 集合推导式

> 大括号除了能用作字典推导式，还可以用作集合推导式，两者仅仅在细微处有差别

```
a = {x for x in 'abracadabra' if x not in 'abc'}
print(a)
---------------------
{'d', 'r'}
```

**注意：因为集合没有键，所有在生成的结果中，不用使用 (键:值)的方式**

## 元组推导式?!

> 那么用圆括号()括起来是不是元组推导式呢？不是！圆括号在Python中被用作生成器的语法了

```
tup = (x for x in range(9))
print(tup)
print(type(tup))
print(tuple(tup))

---------------------------
结果：
<generator object <genexpr> at 0x000000000255DA98>
<class 'generator'>
(0, 1, 2, 3, 4, 5, 6, 7, 8)
```

**注意：用圆括号生成的是生成器，其结果直接能循环。要通过类似方法生成元组，需要显式调用元组的类型转换函数tuple()**

# 运算符

## 算术运算符

**`整数`和`浮点数`进行运算时，自动将整数转换为浮点数**

|                             运算                             | 表达式 |     结果      |
| :----------------------------------------------------------: | :----: | :-----------: |
|                           +（加）                            | 10+20  |      30       |
|                           -（减）                            | 20-10  |      10       |
|                           *（乘）                            |  2*10  |      20       |
| /（除）【0不能做除数】在python3中，除法不论有无复杂类型，结果都会精确到浮点数 |  30/5  | 6.0（浮点数） |
|                        //（向左取整）                        |  31/5  |       6       |
|              %（求余;可以对浮点数进行取余操作）              | 31//5  |       1       |
|                           **（幂）                           |  2**3  |       8       |

`divmod()`函数同时得到商和余数；返回的是元组

`divmod(13,3) ` =>>  (4,1)

### + 法

> 5是表达式：+5，双目运算

```pyth
操作两个数值型数据，加法运算
操作一个数字型数据，整数
操作 str list tuple，起到连接作用
```

### *法

```python
操作两个数字型数据，乘法运算
操作的 str list tuple *n，重复n次
```

## 赋值运算符

| 运算符 | 例子  | 等价   |
| ------ | ----- | ------ |
| +=     | a+=2  | a=a+2  |
| -=     | a-=2  | a=a-2  |
| *=     | a*=2  | a=a*2  |
| /=     | a/=2  | a=a/2  |
| //=    | a//=2 | a=a//2 |
| %=     | a%=2  | a=a%2  |
| **=    | a**=3 | a=a**3 |

**返回新值（新地址）**

## 比较(关系)运算符

> python    动态类型，强类型的语言[不会隐式转换]
>
> js              动态类型，弱类型的语言[会隐式转换]

**所有比较运算符返回 1 表示真，返回0表示假；与True和False等价**

假设 ： a=15;b=30

**3<a<10  可以这么写**

| 运算符 | 描述     | 实例           |
| ------ | -------- | -------------- |
| ==     | 等于     | a==b   =>False |
| ！=    | 不等于   | a!=b   => True |
| >      | 大于     | a>b  => False  |
| <      | 小于     | a<b   => True  |
| >=     | 大于等于 | a>b  => False  |
| <=     | 小于等于 | a<b   => True  |

## 逻辑运算符

| 运算符 | 格式    | 说明                                    |
| ------ | ------- | --------------------------------------- |
| and    | x and y | x为True，返回y的值；x为False，返回False |
| or     | x or y  | x为True，返回True；x为False，返回y的值  |
| not    | not x   | x为True，返回False；x为False，返回True  |

## 同一运算(身份运算符)

> 同一运算用于比较两个对象的存储单元，实际比较的是对象的地址

| 运算符 | 描述                                     |
| ------ | ---------------------------------------- |
| is     | is判断两个标识符是不是引用同一个对象     |
| is not | is not判断两个标识符是不是引用不同的对象 |

**`is`与`==`区别：

1. `is`用于判断两个变量引用对用是否为同一个，即比较对象的地址
2. `==`用于判断引用变量引用对象的值是否相等，默认调用对象的`__eq__()`方法
3. `is`运算符比`==`效率高，在变量和None进行比较时，应该使用`is`

## 成员运算符（in/not in）

**判断某个字符串/列表等（子字符串）是否存在于字符串/列表等中**(a in b)

```python
in :元素在不在arr，在返回True
	arr =[1,2,3]
	1 in arr 
not in：元素在不在  不在返回True
```

## 位运算符

### 源码、反码、补码

正数：源码=反码=补码

负数：最高位为符号位

​	反码：除符号位，全部取反

​	补码：反码+1【符号位不管，不进位】

​	补码 =》反码：继续取反+1

### << 左移

```python
2<<2
2 先转换为二进制数 ,后边补两个0
<< 左移，运算符的二进制数左移若干位，4<<2,4的二进制数左移2位 ； 左移一位相当于乘以2

a<<n
a*2^n
```

### `>>`右移

```python
8>>2
8 先转为二进制数，最高位是1补1,0补0
>> 右移，运算符的二进制数右移若干位，4>>2,4的二进制数右移2位 ； 右移一位相当于除以2

a>>n
a//2^n
```

### &按位与

```python
3&5
3 转换为 二进制 0000 0011
5 转换为 二进制 0000 0101
同1取1，否则取0
```

### |按位或

```python
3|5
3 转换为 二进制 0000 0011
5 转换为 二进制 0000 0101
有1取1，同0取0
```

### ^按位异或

```python
3^5
3 转换为 二进制 0000 0011
5 转换为 二进制 0000 0101
相同取0，不同取1
a=5,
对同一个异或两次，得其本身（a=a^10 a=a^10 => a=5）
```

### ~按位取反

```python
～5
5 转换为 二进制 0000 0101
包括符号位，每位取反  =》 得到补码 =》（取反+1【符号位不动】=》源码）
```





## 运算符的优先级

| 运算符（高->低）                       | 描述               |
| -------------------------------------- | ------------------ |
| **                                     | 指数               |
| ~                                      | 按位翻转           |
| * / % //                               | 乘、除、取模、取整 |
| + -                                    | 加减法             |
| >> <<                                  | 右移、左移         |
| &                                      | 位 ·and·           |
| <=   <   >    >=                       | 比较运算符         |
| <>   ==    !=                          | 是否等于           |
| =   %=   /=   //=   -=   +=   *=   **= | 赋值运算符         |
| is     is not                          | 身份运算符         |
| in not in                              | 成员运算符         |
| not or and                             | 逻辑运算符         |

**实际中，记住以下规格即可**

1. 乘除优先加减
2. 位运算和段数运算  >   比较运算   >   赋值运算   >  逻辑判断

## == 和 is

1. == 比较值是否相等
2. is比较是不是同一个，比较是不是同一块内存



# 流程控制

## 选择结构

> `False、0、0.0、空值None、空序列对象（空列表、空元组、空集合、空字典、空字符串）、空range对象、空迭代对象` ==》都为`假(False)`
>
> 其余都为·真·
>
> “False” =》 为真

### 单分支

```python
if 条件 :
    print("222")
```

### 双分支

```python
if 条件 :
    print("222")
else： #其他情况
	print("55555")
```

### 三元表达式（本质双分支）

```python
三元表达式：
结果1 if 表达式【条件】 else 结果2
例子   print(2 if 2>3 else 3)
```

### 多路分支

**几个分支之间有联系，顺序不能颠倒**

```python
if 条件 :
    print("222")
elif 条件:
    print("33333")
elif  条件:
    print("444444")
else： #其他情况
	print("55555")
```

### 选择结构嵌套

```python
if 条件：
	pass
else 条件：
	if 条件：
    	pass
    elif 条件：
    	pass
    ...
    else：
    	pass
```



```python
score=int(input('请输入分数'))
degree='ABCDE'
num=0
if score>100 or score <0:
    score=int(input('输入不规范，请输入分数'))
else：
	num=score//10
    if num<6:
        num=5
    print(degree[9-num])       
```



## 循环结构

> 重复执行一条或者多条语句
>
> 循环体里至少包含一条改变表达式的语句，要结束控制循环结束

### for循环

> 　遍历字典，默认遍历其键

```python
for i in range（0,5）：
	循环体（pass循环体为空）
range（）对象是一个迭代器对象
range(10)  => 0-9
range(3,10)   =>3-9
range(3,10,2)  =>3,5,7,9
```

### while循环

```python
while 条件表达式：
	循环体
```

### 嵌套循环

```python
# 九九乘法表
for i in range(1,10):
    for j in range(1,i+1):
        print("{0}*{1}*{2}".format(j,i,i*j),end="\t")
    print()
```

### break语句

> break语句可用于while和for循环，用来结束整个循环；
>
> 当有嵌套时，break只跳出最近一层的循环

```python
while True:
    a=input("输入Q结束")
    if a.upper()=="Q":
        print("循环结束")
        break
    else:
        print(a)
```

### continue语句

> continue语句用于结束本次循环，继续下一次
>
> 多个嵌套时，continue应用于最近一层循环

```python
while True:
    a=input("输入Q结束")
    if a.upper()=="Q":
        print("本次循环结束，开启下一次")
        continue
    else:
        print(a)
```

### else语句

```python
for i in range(9):
    循环体
else:
    执行语句
正常结束代码，执行else语句；
遇到break结束。不执行代码
```

```python
while 条件：
	循环体
else:
    执行语句
正常结束代码，执行else语句；
遇到break结束。不执行代码
```

## 循环代码优化

1. 尽量减少循环内部不必要的计算
2. 嵌套循环中，尽量减少内层循环的计算，尽可能向外提
3. 局部变量查询快，尽量使用局部变量

## zip（）并行迭代

```python
names={'x1','x2','x3','x4'}
ages={15,16,17,18}
sexs={'男','女','男'}
for name,age,sex in zip(names,ages,sexs):
    print("{0}--{1}--{2}".format(name,age,sex))

# 循环min（len（names）,len(ages),len(sexs)）    
```

# 函数

1. 函数时可复用的程序代码块
2. 一个程序由一个个任务组成，函数就是代表一个任务或者一个功能
3. 函数时代码复用的通用机制

## 函数的分类

1. 内置函数

   `str()、list()`

2. 标准库函数  import语句导入库的
3. 第三方函数  import语句导入库的
4. 用户自定义函数

## 定义

```python
def 函数名(参数):
    函数体
id(函数名)
type(函数名)
函数值：函数名

调用：
函数名（）
```

### 形参和实参

1. 形参：定义函数时使用，只用于函数内部，多个参数用`，`隔开
2. 实参：调用函数使用

### 函数的注释（文档字符串）

```python
def 函数名(参数):
    '''对函数的说明'''
    函数体
查看文档字符串的方法：
help(函数名,__doc__)
```

## 函数返回值

> 不是必须的

1. 不是必须的
2. 不包含return，则返回None值
3. 一个函数只能执行一个return
4. 如果要返回多个值，用元祖、列表、字典、集合将他们组合起来
5. 用于结束函数，return后面的语句不会执行

## 内存分析

1. 函数(test01())在堆中
2. 函数名（test01）在栈中
3. c=test01 仅仅时将test01在栈中的地址给了c

## 作用域(局部变量和全局变量)

**`global`是python中唯一一个看起来像是关键字声明的语句。但是 并不是一个类型或者大小的声明，他是一个命名空间的声明，他告诉python函数打算生成一个或者多个全局变量名。也就是说，存在于整个模块内部作用于（命名空间）的变量名**

### 全局变量

1. 在函数和类定义之外声明的变量，作用域为定义的模块，从定义位置开始到模块结束
2. 全局变量降低了函数的通用性和可读性，应尽量避免全局变量的使用
3. 全局变量一般做常量使用
4. 函数内要改变全局变量的值，用`global`声明一下

```python
aa=123
def fn1():
    global aa    //不能再声明的时候修改，改变全局变量
    aa=456
fn1() 
print(aa)  //aa=456
```

### 局部变量

1. 在函数体中（包含形式参数）声明的变量
2. 局部变量的引用比全局变量快，优先考虑使用
3. 如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用局部变量

```python
num1=100
def aa():
    num1=456;
    def bb():
        nonlocal num1    //改变局部变量
        num1+=10
    bb()
    print(num1)
aa()
```

### 内存分析

1. 函数调用的时候，创建一个栈帧，调用结束删除
2. 局部变量在栈帧中

### 查看全局/局部变量

```python
print(locals())  #打印输出局部变量
print(globals())   #打印输出全局变量
```

## 参数的传递

> 本质：从实参到形参的复制操作

### 可变参数参数传递

**可变对象（列表、字典、自定义额其他类型等），实际传递还是对象的引用**

> 在函数中不创建新的对象拷贝，而是可以直接修改传递的对象

### 传递不可变对象

**不可变对象（数值，字符串，元组，布尔值），实际传递的还是对象的引用。由于不可变，所以系统会创建一个新对象**

> 发生拷贝，用的是浅拷贝

## 参数的几种类型

### 位置参数

```python
def f1(a,b,c):
    pass

参数必须传够三个，否则报错
```

### 默认值参数

```python
def f1(a,b=10,c=20):
    pass
# b=10放其他类型后面
```

### 命名参数

```python
def f1(a,b,c):
    pass
f1(c=10,a=20,b=1)
# 找形参对应
```

### 可变参数

1. `*arg   将多个参数收集到一个`‘元组‘`对象中

   ```python
   def f1(a,b,*c):
       pass
   f1(8,9,10,11)
   ```

2. `**karg`  将多个参数放到一个`’字典‘`对象中

   ```python
   def f2(a,b,**c):
       pass
   f2(8,9,name='ygx',age=18)
   ```

### 强制命名参数

> **在带星号的“可变参数”后面增加新的参数，必须是“强制命名参数”**

```python
def f1(*a,b,c):
    pass
f1(2,b=3,c=4)
#错位写法f1(2,3,4)  # 报错
```

## lambda匿名函数

1. `lambda 参数:`函数体【只能写一行，表达式一句】
2. `参数：`可以有多个参数  a，b
3. `表达式：`只能有一句，不需要return，自动return
4. `自调用：`（lambda a，b ： a+b）（10,20）
5. `字面量的方式：` fn=lambda a，b ： a+b   fn（10,20）

```python
lambda a,b,c:a+b+c
```

### 适用场景

1. map函数

   ```python
   map（函数，序列）：让序列的每一个元素都执行一个功能
       arr=map（lambda x：x*2,range（0,11））
       arr是一个对象 list（arr）
   map（函数，序列1，序列2）：两个序列对应的元素相作用
       arr=map（lambda x，y：x+y，range（0,11），range（0,11））
       arr是一个对象，list（arr）
   ```

2. filter：筛选

   ```python
   filter（函数，序列）：筛选
       arr=filter(lambda x:x>5,range(1,11))
   ```

3. reduce:放在functools包中，

   ```python
   functools.reduce（函数，序列）
   
   functools.reduce（lambda x，y:x+y，range（1,11））
       x代表前几次操作的结果
       y代表现在操作的数值
       返回的函数
   ```

## eval()函数

1. 功能：将字符串str当成有效的python表达式来计算并返回计算结果
2. 语法：`eval(一个python表达式或者函数compile()返回的代码计算值 [,必须是字典格式 [,任意映射对象]])`

```python
a=10
b=20
eval("a+b")  =>30

dict1=dict(a=100,b=200)
eval("a+b",dict1) ===> 300
```

## 递归函数

> 如果一个函数在内部不调用其他的函数，而是自己本身的话，这个函数就是递归函数

递归阶乘

```python
def jiecheng(num):
    if num:
        return 1
    else:
        return num*jiecheng(num-1)
    
```

## 嵌套函数

> 函数内部定义的函数

1. 封装：数据隐藏

2. 闭包

3. 降低重复的代码

4. nonlocal

   ```python
   def outer():
       b=10
       def inner():
           nonlocal b  #声明外部函数变量
           print(b) # 不用nonlocal只能访问；用了就可以修改了
   ```


### 返回值高阶函数

```python
返回值是另个函数名
def fn1（）：
	def aa（）：
		print（“this is aa”）
	return aa   
bb=fn1()    //bb==aa
bb()

```

### 参数高阶函数，传入的参数是另一个函数名

## LEGB规则

> LEGB规则查找规则:local =》Enclosed  =》 global   =》built in  （保留）

## 闭包函数

> 在函数中可以嵌套（定义）另一个函数时，如果内部函数引用了外部函数的变量，则可能产生闭包函数。闭包函数可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数多次被调用的过程中，这些私有变量能够保持其持久性。

```python
def aa()：
	num=123
    def bb（）：
    	print（num1）
    return bb
bb=aa（）    //type（bb）    <class 'function'>
bb（）
```

## 装饰器

> 装饰器实际上就是为了给某程序添加功能

### 使用场景：

> 比如修改程序已经上线或者已经被停用，那么就不能大批量的修改源代码，这个是不科学的，也是不现实的

### 装饰器的三个原则

> 不能修改被装饰的函数的源代码

> 不能修改被装饰的函数的调用方式

> 满足1 .2情况下给程序添加新功能

### 装饰器定义公式

> 只接受一个参数（函数）

<函数+实参高阶函数+返回值高阶函数+>

```python
写法1
    import time
    def newtest(f):
        def new():
            start = time.time()
            f()
            end = time.time()
            print("运行总时间：", end - start)
        return new
    def text():
        time.sleep(2.5)
        print("this is running")
    text=newtest(text)
    text()
 写法2
     import time
     def newtest(f):
        def new():
            start = time.time()
            f()
            end = time.time()
            print("运行总时间：", end - start)
        return new
    @newtest
    def text():
        time.sleep(2.5)
        print("this is running")
     text()
```

### 传参

```python
函数的柯里化
    def aa(a):
        def bb(b):
            print(a+b)
        return bb
    aa(2)(3)
装饰器传参
    import time
    def text1(a):
        def newtest(f):
            def new():
                start = time.time()
                f()
                end = time.time()
                print("运行总时间：", end - start)
                print("canshu :",a)
            return new
        return newtest
    //@texts     //后执行
    @text1(5)   //先执行
    def text():
        time.sleep(2.5)
        print("this is running")
    # text=text1(5)(text)
    text()
	
```

## 类装饰器

```python
class AA():
    def __init__(self,func):
        self.__func=func
     
    def __call__(self,*args,**kwargs):
        print('新增功能代码')
        self.__func()
        
@AA
def test1():
    print('test1')
    
test1()    
```





# 面对对象

## 常用术语

> 数据成员：类变量或者实例变量，用于处理类及其实例对象的相关数据

> 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的重写（覆盖）

> 实例变量：定义在方法中的变量，只做用于当前实例的类

> 继承：即一个派生类继承基类的字段和方法，继承也允许把一个派生类的对象作为一个基类对象对待。

> 实例化：创建一个类的实例，类的具体对象

> 对象：通过类定义的数据结构实例，对象包括两个数据成员（类变量和实例变量）和方法

> 面向对象编程就是将数据和操作数据相关的方法封装到对象中，组织代码和数据的方式更接近人的思维，从而大大提高编程的效率

## 对象

> 将不同类型的数据、方法（函数）放到一起

## 类的定义

> 制造东西的模具
>
> 用来描述具有相同的属性和方法的对象的集合，它定义了该集合中每个对象所共有的属性和方法，对象是类的实例

类就是将属性和方法放到一起

```python
class Student:  #类名首字母大小；驼峰命名 
    def __init__(self,name,score):   #构造方法；self指当前对象本身;  => 存放类属性
        self.name=name
        self.score=score
    def saf_score(self):
        print("{0}的分数是{1}".format(self.name,self.score))
```

```python
例子：
class play:
    name=“老J”  #类属性、静态变量、静态数据,不随实例的变化而变化	
    def __init__(self):    #初始化函数
        self.name="小A"     #实例的属性，#类.name，实例.name （所有实例调用同一个数据）
    #方法
    def type(self):    //self相当于js的this，类的时候有时传入slef
        print("司令")
    def nl(self):
        print("指挥")
    @staticmethod    //静态方法，不能调用实例的属性和方法，但同时也不能调用类的属性和方法，也不能调用类的静态方法
    def say():   //调用   play.say（）
        print("这是say方法")     //静态方法
    @classmethod   //类方法，不能调用实例的属性和方法,但是可以调用类属性和方法,也可以调用静态方法和属性【先有的这个函数】
    def say1(cls):
        print("这是类方法")
        print(cls.name)
        cls.say2()
        cls.say()
    @classmethod
    def say2(cls):
        print("hhh")
```

## 构造函数/方法`__init__()`

1. 必须有self，且第一个参数是self
2. self相当于java、c++中的this；c中的this指针
3. 可以自己制定self的名字

```python
def __init__(self,name,score):   #构造方法；self指当前对象本身;  => 存放类属性
    self.name=name
    self.score=score
```

## 实例属性

> 属于我们的对象，也称为‘实例变量’

1. 一般在`__init__()`方法中

   ```python
   self.属性名=属性值
   ```

2. 新增特有属性

   ```python
   实例对象.属性名=属性值
   ```

## 实例方法

> 从属于实例对象

```python
def say_score(self [，形参列表]):
    pass

def __new__(cls):    #创建对象/方法的机理
   return object.__new__(cls)
__new__(cls)：
__new__至少有一个参数cls，代表要实例化的类，此参数在实例化时python自动提供
__new__必须有返回值，返回出实例

def __str__(self):    #给实例一个描述
        return "这是一个汽车实例"
def __repr__(self):    #给实例一个描述
        return "这是一个汽车实例"
```

## 其他操作(魔法方法)(特殊的类属性)

1. `对象.__dict__`  对象的属性字典
2. isinstans(对象,类)  ： 判断对象是不是类的实例对象
3. `print(Car.__name__)  `#类的名字
4. `print(Car.__doc__)`   #对类的描述，注释
5. `print(Car.__bases__)  `#所有的父类（有继承），返回一个元组
6. `print(Car.__base__)   `  #父类
7. `print(Car.__module__)`     #返回类所在的模块
8. `print(Car.__class__) `      #返回对应的类

## 类对象



## 类属性

> 从属于“类对象”的属性
>
> 被所有实例对象共享
>
> 类变量在整个实例化的对象中是公用的，类变量定义在类中且在函数体之外，类变量通常不作为实例变量使用

1. 定义

   ```python
   class Student:
       属性名=“属性值”
       
   ```

2. 内部调用

   ```python
   Student.属性名   = 增删改的值
   ```

## 类方法

> 从属于类对象的方法

1. 定义

   ```python
   @classmethod
   def 类方法名称(cls  [,形参列表])：
   	pass
   ```

2. 必须在方法的上一行加`@classmethod`

## 静态方法

1. 定义

   ```python
   @staticmethod
   def 静态方法名称([形参列表])：
   	pass
   ```

## `__del__`（析构函数）和垃圾回收机制

> `__del__`实现对象被销毁时所需要的操作

> python实现自动的垃圾回收，当对象没有被引用时（引用计数为0），由垃圾回收器调用`__del__()`方法
>
> 也可以用del方法

## `__call__（）`方法和可调用对象

> 可以向函数一样被调用

a=Stundet

a()   =>>在调用对象的`__call__`方法

## 方法没有重载

**定义多个同名的方法，只有最后一个有限**

## 方法的动态性

> python是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法

**类.方法名=外部的函数名**

## 私有属性和私有方法（实现封装）

> python对于类的成员没有严格的访问控制权限，这与其他面对对象语言有区别。

**关于私有属性和私有方法，有如下要点**

1. 通常约定，两个下划线开头的属性是私有的（private），其他的为公共的（public）
2. 类内部可以访问私有属性/方法
3. 类外部不能直接访问私有属性/方法
4. 类外部可以通过“`_类名__私有属性/方法名 `"访问私有属性/方法

**测试**

```python
class Em:
    __company="6666"
    def __init__(self,name,age):
        self.name=name
        self.__age=ge     # 私有属性
    def __wp(self):  #私有方法
        pass
    print(Em.__company)
e=Em("ygx",18)

e.name
e._Em__age  #私有属性
e._Em__wp()  #调用方法
Em._Em__company  
```

## @property装饰器

> @property 可以将一个方法的调用变成“属性调用”
>
> 用来给其增加新东西/功能

```python
class Em:
    @property
    def salary(self):
        return 3000;
e=Em()
print(e.salary)

不能设置属性值
```

```python
class Em:
    def __init__(self,name,salary):
        self.__name=name
        self.__salary=salary
       
    @proprety
    def salary(self):
        return self.__salary
    """
    def get_salary(self):
   		return self.__salary
    """
    
    @proprety.setter
    def salary(self,salary):
        if 1000<salary<50000:
            self.__salary=salary
        else:
            print("录入错误")
    """
    def set_salary(self,salary):
   		if 1000<salary<50000:
            self.__salary=salary
        else:
            print("录入错误")
    """
     
    # salary=property(get_salary,set_salary)  ==> 访问 实例.salary   
E=Em()
E.salary   =>获取
E.salary=2000   => 设置
```

## 面向对象的三大特征

### 封装（隐藏）

> 隐藏对象的属性和实现细节，只对外提供必要的方法（细节封装，显露相关调用方法）
>
> 对内部数据进行保护（隐藏），或合理的保护【私有，公有】

```python
issubclass(sub,parent)   判断sub是否为parent的子类  返回bool
isinstance(ins,class)    判断ins是否为class的实例，返回bool
hasattr(obj,"attr")      判断obj是否有attr属性，返回bool
getattr(obj，"attr")     获取obj中的attr属性
setattr(obj,attr.value)  设置obj中attr属性
delattr(obj,attr)        删除obj中的attr属性
dir()                    列出类或者实例的属性和方法  以列表的方式
super()                  寻找父类信息super(type,[object -or-type])
	Python3和Python2的一个区别是Python3可以使用直接使用
super().xxx              代替super(Class,self).xxx
vars(object)             返回类或实例的属性  ，   以字典的形式
```



### 继承

> 让子类具有父类的特征，提高代码的重用性（可以增加新的功能　　或者　　改进已有的算法）

父类（基类）

子类（派生类）

#### 语法

**支持多重继承，一个子类可以集成多个父类。**

```python
class 子类类名(父类１ [,父类２．．]): #可以继承多个，但是优先继承离他近的类[就近原则，深度优先]
    类体 
```

类定义中没有指定父类，默认父类是`object类`

定义子类时，必须在其构造函数调用父类的构造函数`父类名.__init__(self,参数列表)`  逻辑必须，语法不必须

子类.mro() =》显示继承关系

```python
class Person:
    def __init__(self,name,age):
        self.name=name
        self.__age=age  #设置私有属性
	def say_age(self):
        print("我也不知道")
        
class Student(Person):
    def __init__(self,name,age,score):
        Person.__init__(self,name,age)
        self.score=score

s=Student("123",18,60)
s.name
s._Person__age   #调用私有属性
s.say_age()
```

#### 方法重写

> 子类可以重新定义父类中的方法，就会覆盖父类的方法

```python
class Person:
    def __init__(self,name,age):
        self.name=name
        self.__age=age  #设置私有属性
	def say_age(self):
        print("我也不知道")
        
class Student(Person):
    def __init__(self,name,age,score):
        Person.__init__(self,name,age)
        self.score=score
	def say_age(self):
        print("我的年龄是".format(self.__age))
```

#### `__str__`用于返回对象的描述

> 一般在`object`类中

```python
class Person:
    def __init__(self,name):
        self.name=name
    # 重写__str__    
    def __str__(self):
        return "我的名字是{0}".format(self.name)

p=Person("ygx")
print(p)  => 我的名字是ygx

没有重写前：返回对象的内存
```

#### 多重继承

> 会使”类的整体层次“搞得异常复杂

```python
class A:
    def a(self):
        print("A")
        
class B:
    def b(self):
        print("B")
        
class C(A,B):  =>先用A的同名方法
    def c(self):
        print("C") 
    def b(self):
        print("CC")
        
```

#### super()获得父类定义

> 不是父类对象

```python
class A:
    def say(self):
        print("A:",self)
        
class B(A):
    def say(self):
        super.say()  #等价与 A.say(self)  #A.__new__(cls,参数列表)
        print("B:",self)        
```

### 多态

> 同一个方法调用由对象的不同产生不同行为

#### 特点

1. 多态是方法的多态，属性没有多态

2. 多态的存在有2个必要条件

   1. 继承
   2. 方法重写

   ```python
   class A:
       def shout(self):
           print("**叫了一声")
           
   class B(A):
       def shout(self):
           print("B叫了一声")
           
   class C(A):
       def shout(self):
           print("C叫了一声")
           
   def ABC(m):
       if isinstance(m,A):
           m.shout()   #多态
       else:
           print("不叫了")
   ```

## 特殊方法和运算符重载



| 特殊方法                                   | 说明                |
| ------------------------------------------ | ------------------- |
| `__add__`                                  | 加法                |
| `__sub__`                                  | 减法                |
| `__lt__`,`__le__``__eq__`                  | 比较运算符          |
| `__gt__,__ge__,__ne__`                     | 比较运算符          |
| `__or__,__xor__,__and__`                   | 或，异或，与        |
| `__lshift__,__rshift__`                    | 左移，右移          |
| `__mul__,__truediv__,__mod__,__floordiv__` | c乘除，模运算，整除 |
| `__pow__`                                  | z会输运算           |



| 方法          | 说明     | 例子            |
| ------------- | -------- | --------------- |
| `__init__`    | 构造方法 | 对象创建：p=P() |
| `__del__`     | 析构方法 | 对象回收        |
| `__repr`      | 打印     | print(a)        |
| `__str__`     | 描述     | print(a)        |
| `__call__`    | 函数调用 | a()             |
| `__getattr__` | 点号运算 | a.xxx           |
| `__setattr__` | 数值赋值 | a.xxx=value     |
| `__getitem__` | 索引运算 | a[key]          |
| `__setitem__` | 索引赋值 | a[key]=value    |
| `__len__`     | 长度     | len(a)          |

### 重写＋

```python
class Person:
    def __init__(self,name):
        self.name=name
    
    def __add__(self,other):
        if isinstance(other,Person):
            return "{0}-{1}".format(self.name,other.name)
        else:
            return "不是同类对象"
        
p1=Person("ygx")
p2=Person("dxn")
p=p1+p2   => ygx-dxn
```

## 特殊属性

| 特殊方法/属性            | 含义                   |
| ------------------------ | ---------------------- |
| `obj.__dict__`           | 对象的属性字典         |
| `obj.__class__`          | 对象所属的类           |
| `class.__bases__`        | 类的基类元组（多继承） |
| `class.__mro__`          | 类层次结构             |
| `class.__base__`         | 类的基类               |
| `class.__subclasses__()` | 子类列表               |

## 对象的浅拷贝 和 深拷贝

```python
class phone:
    def __init__(self,cpu,screen):
        self.cpu=cpu
        self.screen=screen
        
class CPU:
    def jisuan(self):
        print("算术")
        print("cpu对象：",self)
        
class Screen:
    def xianshi(self):
        print("显示")
        print("Screen对象：",self)
        
#对象赋值
c1=CPU()
c2=c1   => 地址一样

import copy
#浅拷贝
s1=Screen()
m1=phone(c1,s1)
m2=copy.copy(m1)
# m1和m2不一样，cpu、screen地址一样

m3=copy.deepcopy(m1)
# m1、m3不一样，cpu、screen地址不一样
```

## 组合

> 用属性指向对象

```python
class A2:
    def say(self):
        print("aaaa")

        
class B2:
    def __init__(self,a):
        self.a=a
        
a2=A2()
b2=B2(a2)
b2.say()
```

## 工厂模式和单例模式

### 工厂模式

> 工厂模式实现了创建者和调用者的分离，使用专门的工厂类选择实现类、创建对象进行统一管理和控制

```python
class Dz:
    def __init__(self):
        self.name="大众"
    def run(self):
	    print("启动")
    def stop(self):
	    print("熄火")
class Bmw:
	def __init__(self):
		self.name="宝马"
	def run(self):
		print("启动")
	def stop(self):
		print("熄火")
class factory:
	def creatcar(self,type):
		if type=="dz":
			obj=Dz()
		elif type=="BMW":
			obj=Bmw()
		return obj
cf=factory()
c=cf.creatcar("dz")
print(c.name)
```



### 单例模式

```python
class person:
    __instance=None
    def __new__(cls):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
        return cls.__instance
    def __init__(self):
        pass
    def say(self):
        print(self.name)
p=person()
p1=person()
p.name="花花"
p1.say()
```

## 属性详解

### xx

```python
import 类
类._xx

from 类 import * _xx
```

### _xx

```python
import 类
类._xx

使用from 类 import * _xx无法使用
```

### __xx

```python
私有属性/私有方法
只能在类内部访问

类外用 ： 实例._类__xx

名字重整 =》 _类名__xx
```

### `__xx__`系统

### xx_

> 用来区分变量名/方法

## 元类

```python
类=type(类名,(父类,..),{属性,方法})
#type(类名,(父类,..),{'属性名':'','方法名':方法名})
Person=type('Person'，（），{})

```







# 异常

> 异常就是不正常，当python检测到一个错误时，解释器就无法就系执行下去了，反而出现了一些提示错误，这就是异常
>
> 语法和逻辑上的，语法错误是软件结构上的错误，导致不能被解释器解释或者编译器无法编译

## 引入异常

```python
#需求 ：输入被除数a与除数b，求商，并打印结果

# 以下程序使程序重心偏移，不符合要求
a = input("请输入被除数")
b = input("请输入除数")
if a.isdigit（） and b.isdigit():
    a=int(a)
    b=int(b)
    if b:
    	c=a/b
    else:
        print("除数不能为0")
else:
    print("输入类型有误")

# 以下程序程序重心不偏移
a = input("请输入被除数")
b = input("请输入除数")
try:
    a=int(a)
    b=int(b)
    c=a/b
except:
    print("抛出异常")
```

## 多个except

```python
#多个except
a = input("请输入被除数")
b = input("请输入除数")
try:
    a=int(a)
    b=int(b)
    c=a/b
except ValueError:
    print("数据类型有误")
except ZeroDivisionError:
    print("除数不能为0")
#接下来如果捕获不到，python解释器处理异常
except Exception: #不执行python的异常了
    print("其他异常")
```

## except多个异常

> 使用元祖存储异常，多个异常之间没有顺序要求

```python
#多个except
a = input("请输入被除数")
b = input("请输入除数")
try:
    a=int(a)
    b=int(b)
    c=a/b
except (ValueError,ZeroDivisionError,Exception) as e: 
    print(type(e.args))    
```

## try-except-finally-else

```python
try:
    pass
except 异常 as 别名:
    pass
else:
    没有异常执行的代码
finally:
    最终执行的代码
```



```python
try:
    file=open("123.txt",'w',encoding="utf-8")
	file.write("He")
	file.write("Word")
	file.write([1,2,3])  #write只能写入字符串
    print("写入完毕")
except Exception as e:
    print(e.args)
else:
    print("没有异常，操作成功")
finally:
   file.close() 
	print("关闭文件")
```

## 异常的传递



```python
def test1():
    print("-"*10+"test1开始"+"-"*10)
    print(aa)
    print("-"*10+"test1结束"+"-"*10)
    
def test2():
    print("-"*10+"test2开始"+"-"*10)
    test1()
    print("-"*10+"test2结束"+"-"*10) 
    
def test3():
    print("-"*10+"test3开始"+"-"*10)
    try:
        test2()
    except:
        pass
    print("-"*10+"test3结束"+"-"*10)    
    
test3()    
```

## 自定义异常

```python
# 需求：定义学生类，私有属性性别，提供对应的设置值以及访问值的方法
#自定义异常
class sexException(BaseException):
    def __init__(self):
        super.__init__()
        self.errMsg="性别只能为男或者女"

class Student:
    def __init__(self,name,sex):
        self.name=name
        #self.__sex=sex
        self.setSex(sex)
        
    def setSex(self,sex):
        if sex == "男" or sex == "女":
            self.__sex=sex
        else:
            raise sexException()   #raise 用于排除异常

    def getSet(self):
        return self.__sex
    
    def showInfo(self):
        print("我叫%s"%self.__sex)
        

try:
    s1=Student("ygx","男")
except sexException as e:
    print(e.args,e.errMsg)
    
try:
    s1.setSex("半男半女")
except sexException as e:
    print(e.args,e.errMsg)
```



```python
class Myexcept(Exception):
    def __init__(self):
        self.name="这是我的异常"
    
num=int(input("请输入一个数字："))
if num<0:
    try:
        raise Myexcept
    except Myexcept:
        print("捕获到异常")
```



```python
class myExcept(Exception):
    def __init__(self,info):
        self.name="这是我定义的异常"
        self.info=info #提示信息
    def __str__(self):
        return "myExcept错误"
    
 num = int(input("请输入一个数："))
if num < 0:
    try:
        raise myExcept("myExcept错误")
    except myExcept as e:
        print(e)
```



## 总结

1. except语句不是必须的，finally语句也不是必须的，但是二者必须有一个，否则就没有try的意义
2. except语句可以有多个，python会按照except语句的顺序依次匹配你指定的异常，如果异常已经处理就不会进入后面的except语句
3. except语句可以以元组的形式同时指定多个
4. except语句后面如果不指定异常类型，则默认捕获所有异常，可以通过logging或者sys模块获取当前异常
5. 如果捕获异常后重复抛出，则使用raise  后面不带任何参数或信息
6. 不建议捕获并同时抛出同一个异常

## 所有异常

```python
BaseException
 +-- SystemExit  解释器请求退出
 +-- KeyboardInterrupt  用户中断执行（ctr + c）
 +-- GeneratorExit   生成器发生异常来通知退出
 +-- Exception   常规错误基类
      +-- StopIteration 	迭代器没有更多的值
      +-- StopAsyncIteration
      +-- ArithmeticError   数值计算错误基类
      |    +-- FloatingPointError   浮点计算错误
      |    +-- OverflowError    数值运算超出最大限制
      |    +-- ZeroDivisionError    除(或取模)零 (所有数据类型)
      +-- AssertionError    断言语句失败
      +-- AttributeError    对象没有这个属性
      +-- BufferError   
      +-- EOFError  没有内建输入，到达EOF标记
      +-- ImportError   导入模块失败
      |    +-- ModuleNotFoundError
      +-- LookupError   无效数据查询基类
      |    +-- IndexError 序列中没有此索引(index)
      |    +-- KeyError 映射中没有这个键
      +-- MemoryError   内存溢出错误
      +-- NameError 未声明未初始化的本地变量
      |    +-- UnboundLocalError 	访问未初始化的本地变量
      +-- OSError   操作系统错误
      |    +-- BlockingIOError 操作阻塞设置为非阻塞操作的对象（例如套接字）时引发
      |    +-- ChildProcessError 子进程上的操作失败时引发
      |    +-- ConnectionError 连接相关的问题的基类
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError 尝试创建已存在的文件或目录时引发
      |    +-- FileNotFoundError    在请求文件或目录但不存在时引发
      |    +-- InterruptedError 系统调用被输入信号中断时触发
      |    +-- IsADirectoryError 在目录上请求文件操作时引发
      |    +-- NotADirectoryError 在对非目录的os.listdir()事物请求目录操作（例如）时引发
      |    +-- PermissionError 尝试在没有足够访问权限的情况下运行操作时引发 - 例如文件系统权限。
      |    +-- ProcessLookupError 当给定进程不存在时引发
      |    +-- TimeoutError 系统功能在系统级别超时时触发。
      +-- ReferenceError    弱引用(Weak reference)试图访问已经垃圾回收了的对象
      +-- RuntimeError  一般的运行时错误
      |    +-- NotImplementedError  	尚未实现的方法
      |    +-- RecursionError
      +-- SyntaxError 一般的解释器系统错误
      |    +-- IndentationError 缩进错误
      |         +-- TabError    Tab 和空格混用
      +-- SystemError Python 语法错误
      +-- TypeError     对类型无效的操作
      +-- ValueError    传入无效的参数
      |    +-- UnicodeError  Unicode 相关的错误
      |         +-- UnicodeDecodeError  	Unicode 解码时的错误
      |         +-- UnicodeEncodeError  Unicode 编码时错误
      |         +-- UnicodeTranslateError   Unicode 转换时错误
      +-- Warning   警告的基类
           +-- DeprecationWarning   关于被弃用的特征的警告
           +-- PendingDeprecationWarning    关于特性将会被废弃的警告
           +-- RuntimeWarning   可疑的运行时行为(runtime behavior)的警告
           +-- SyntaxWarning    可疑的语法的警告    
           +-- UserWarning  用户代码生成的警告
           +-- FutureWarning    关于构造将来语义会有改变的警告
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```



# 模块

## 概念

> python模块（Module），是一个python文件，以.py结尾
>
> 以.py为后缀的文件，都可以被称为模块

## 包含的内容

1. 变量
2. 函数
3. 面向对象=》    类-》对象
4. 可执行代码

## 好处

管理方便，易维护；降低复杂度

## 模块的使用

1. 直接导入模块

   > 再导入模块的时候，模块会执行一遍
   >
   > 解决办法：
   >
   > ```python
   > 在模块中新增
   > if __name__=="__main__":
   >     pass
   > ```

   ```python
   import 模块名1，模块名2，...
   #使用
   模块名.函数名（参数）
   模块名.类
   模块名.变量
   ```

2. 导入模块中的相关数据

   ```python
   from 模块 import 函数名，变量，类
   #使用
   可以直接用函数名、变量、类
   ```

3. 自定义模块

   ```python
   和上两种一样
   在第二种方案是，一个个填写比较麻烦，解决办法：
   from 模块 import *
       *默认导入所有
       如果在模块中手动添加`__all__=[]`之后，在 * 之不能用了
       如果在模块中手动添加`__all__=[‘类/变量/函数’]`之后，导入all中包含的内容，其他不引入[字符串形式]   =》 python2中常用，python3不常用
   ```

## 包

### 概念

> 一个文件夹就是一个包，必须包含一个`__init__.py`文件

### 作用

1. 将模块归类，整理方便
2. 防止重名【包名.模块名】

### 使用

1. 直接导入模块

   ```python
   import 包名.模块名1，包名.模块名2，...
   #使用
   包名.模块名.函数名（参数）
   包名.模块名.类
   包名.模块名.变量
   ```

2. 导入模块中的相关数据

   ```python
   from 包名.模块 import 函数名，变量，类 as 别名
   #使用
   可以直接用函数名、变量、类
   
   # 使用相对路径引入子包
   #使用点的这种模式从不是包的目录中导入将会发生错误
   #在顶层的脚本的简单模块中，他们不起作用
   #包的部分被作为脚本直接执行，那他们将不起作用
   
   demo.py
       from bao1.bao2.b import a4
       from bao1.c import a3
       a3()
       a4()
   bao1文件夹
   	__init__.py
       a.py
           def a1():
               print("4556")
           def a2():
               print("4556")
           def a3():
               print("4556")
           def a4():
               print("4556")
        c.py
           from .a import a3    #引用同一级的
     
   	 bao2文件夹
           __init__.py
           b.py
               from ..a import *     #返回上一级的引用
   ```

3. 通过字符串导包（需要解码）

   > import_module知识简单地执行和import相同的步骤，但是返回生成的模块对象，只需要将其存储在一个变量中，然后像正常模块一样使用
   >
   > 如果正在使用的包，import_module（）也可以用于相对导入，但是需要给他额外的参数

   ```python
   import importlib
   b=importlib.import_module('.b',__package__)
   b.    调用
   ```

### 重新加载文件

```python
import spam
import imp
imp.reload(spam)
```

### 包的合并/利用命名空间导入目录分散的代码

> 合并的是文件夹，不是包

```python
main.py
	import sys
    print(sys.path)
    sys.path+=["E:\\路径\\xb","E:\\路径\\xm"]   #新加的路径
    或者 sys.path.append（路径）
    #双斜杠路径
    from spam import xbd,xmd
    
xb文件夹
	spam文件夹
    	xbd.py
        	xb="小bai的"
			print(xb)
 xm文件夹
	spam文件夹
    	xmd.py
        	xm="小bai的"
			print(xm)
```

### 模块的组合/分割

```python
demo.py
	from bao1.bao2.bao3 import *
    a=A()
    b=B()
    a.say()
    b.say()
bao1文件夹
	__init__.py
    bao2文件夹
    	__init__.py
    	bao3文件夹
    		__init__.py
            	from .a import A    #分模块
				from .b import B
            a.py
            	class A:
                    def say(self):
                        print("这是A类")
            b.py
            	class B:
                	def say(self):
                        print("这是B类")
```

### `__init__.py`的使用

> 初始化模块；首次使用包中的模块时，`__init__.py`会被执行一次

> 可以存放和普通模块一样的代码

> 一般会写一些辅助代码，使使用者更方便使用模块

```python
import 模块

# 导入模块中的内容
from .模块 import *
```

### 读取位于子包中的文件数据

```python
文件组织如下
mypackage
	__init__.py
    somedata.dat
    spam.py
假设spam.py文件要读取somedata.dat文件中的内容：
spam.py
	import pkgutil
    data=pkgutil.get_data(__package__,'somedata.dat')   #读取到的是unicode数据
    或者
    f=open('mypackage/somedata.dat','r')
    con=f.read()
```

### 运行目录或压缩文件（zip压缩包）

```python
__main__.py
```

## 案例

```python
案例
demo.py
	import a,b
    # import bao1.a,bao1.b
    from bao1 import a as a2 #as相当于给a起了一个别名
    #from bao1.a import a1,aa2
    from bao1.a import *   #全部导入【__all__=['aa2','aa3']   #指定用户想要全部导入的内容】，和单个导入不冲突
    a.a()
    b.b()
    a2.a1()
    aa2()
a.py
	def a():
    	print("这是a模块下的a方法")
    	
b.py
	def b():
    	print("这是b模块下的b方法")

bao1下的——init——.py        
bao1下的a.py
	def a1():
        print("这是bao1下的a模块下的a1方法")
    def aa2():
        print("这是bao1下的a模块下的a2方法")
    def a():
        print("这是bao1下的a模块下的a方法")
    __all__=['aa2','aa3']   #指定用户想要全部导入的内容
bao1下的b.py
	def b():
    	print("这是bao1下的b模块下的b方法")
```

## 模块搜索路径

```python
import sys
list1=sys.path   #模块搜索路径
1. 不在，手动加入，sys.append("自定义模块路径")
	路径用："/"或者"\\"
    
2. 将自定义模块，发布到系统目录
```

## 模块的发布

### 原因：

自定义模块，切换项目后，不能用

### 步骤

1. 确定发布模块（目录）

   |--setup.py

   |--包名

   ​	| --自定义模块

2. setup的编辑工作

   `setup()`

   ```python
   from distutils.core import setup
   setup(name="压缩包名字",version='1.0',description="描述",author="作者",py_modules=['包名1.模块1','包名1.模块2','包名2.模块1'])
   # 可选参数：description="描述",author="作者"
   ```

3. 构建模块

   `python setup.py build`

4. 发布模块

   `python set.py sdist`

### 模块发布的安装

1. 命令安装

   1. 找到压缩包解压
   2. 进入文件夹
   3. python setup.py install

2. 暴力安装

   直接将要安装的包和模块复制过去

## 打包上传自己的包

1. 建立层级目录，如下
   	/example_pkg
     	  /example_pkg
       	  __init__.py
     	setup.py
     	LICENSE
     	README.md
2. 编辑setup.py
   	import setuptools

```
with open("README.md", "r") as fh:
		long_description = fh.read()

setuptools.setup(
	name="example_pkg",
	version="0.0.1",
	author="Example Author",
	author_email="author@example.com",
	description="A small example package",
	long_description=long_description,
	long_description_content_type="text/markdown",
	url="https://github.com/pypa/sampleproject",
	packages=setuptools.find_packages(),
	classifiers=[
    	"Programming Language :: Python :: 3",
    	"License :: OSI Approved :: MIT License",
    	"Operating System :: OS Independent",
	],
)
```

3. 编辑readme文件
   	对程序的说明
4. 编辑license文件

```pyt
Copyright (c) 2018 The Python Packaging Authority

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


```

5. 更新所有的工具 
   	`（setuptools wheel）
      	python3 -m pip install --user --upgrade setuptools wheel
      	（twine）
      	python3 -m pip install --user --upgrade twine`
6. 打包
   	`python3 setup.py sdist bdist_wheel`
7. 上传
   	`twine upload 【--repository-url https://test.pypi.org/legacy/】 dist/*
      	 【】内为测试地址，不写默认进入官网上传`



## 模块导入的问题

1. 那些模块可以被引入

2. 被引入之后的模块更新问题

   ```python
   import spam
   import imp
   imp.reload(spam)
   ```

# 常用包

## json

### dumps

> 将python对象转换为json字符串；返回一个字符串对象

```python
import json
json.dumps([1,2,3,4]) =>'[1,2,3,4]'
json.dumpss({"city":"北京","price":"13.00"},ensure_ascii=False) => '{"city":"北京","price":"13.00"}'
```

### loads

> 将json字符串转换为python对象

```python
import json
json.loads('[1,2,3,4]') =>[1,2,3,4]
json.loads('{"city":"北京","price":"13.00"}') =>{"city":"北京","price":"13.00"}
```

### dump

> 将python内置类型序列化为json对象后写入文件

```python
json.dump(obj,open('文件','a+',encoding='utf-8'),ensure_ascii=False)
```

### load

> 读取文件中的json形式的字符串转换为python类型

```python
json.load(open('文件'))
# 文件的内容是单条
```



## pickle模块【持久化保存】

```python
obj=[{"name":"xb","sex":"男"}]
import pickle #导包
 with open("demo.txt",'wb') as f:
        pickle.dump(obj,f)
 with open("demo.txt",'rb') as f:
       obj=pickle.load(f)
        
 实例：
    import pickle
    obj=[{'name':"杨国璇"}]
    with open('demo1.txt','wb') as f:
        pickle.dump(obj,f)
    with open('demo1.txt','rb') as f:
        obj=pickle.load(f)
    print(obj[0]['name']
```

- pickle默认二进制存储

## CSV

### 以列表的形式写

```python
import csv
with open("demo2.csv",'w',newline="") as f:
     writer=csv.writer(f,dialect="excel")
     writer.writerow(['id','name','sex','tell'])
     writer.writerows([
         ['1','yxg','n','4555'],
         ['1','yxg','n','4556'],
         ['1','yxg','n','4557']
     ])
```

### 以字典的方式写

```python
import csv
with open("demo2.csv",'w',newline="") as f:
write=csv.DictWriter(f,['id','name','sex','tell'])
    write.writeheader()    #写表头
    write.writerow({'id':'2015','name':'ygx','sex':'nn'})   //写单行
    write.writerows([      //写多行
        {'id':'2015','name':'ygx','sex':'nn1'},
        {'id':'2015','name':'ygx','sex':'nn2'},
        {'id':'2015','name':'ygx','sex':'nn3'}
    ])  
```

## os包

> 对系统、文件进行操作

```python
os.system("cls")   命令控制台//清屏
os.path  路径处理  检测路径
	os.path.isfile（dir） 输出dir是否是文件
os.listdir（"文件名"）   显示文件夹下的所有文件或者路径
os.mkdir("文件名")  创建文件夹
os.path.isfile（） 是否是文件
os.path.isdir（） 是否是路径
```

```python
遍历所有的文件和路径同时复制
import os,os.path
def copyFile(dir):
    if os.path.isfile(dir):
        f=open(dir,"r")
        con=f.readlines()
        f.close()
        f1=open("副本"+dir,"w")
        f1.writelines(con)
        f1.close()
    else:
        os.mkdir("副本"+dir)
        for i in os.listdir(dir):
            copyFile(dir+"/"+i)
copyFile("text")
```

## time



## math

1. ceil:取大于等于x的最小的整数值，如果x是一个整数，则返回x
2. copysign:把y的正负号加到x前面，可以使用0
3. cos:求x的余弦，x必须是弧度
4. degrees:把x从弧度转换成角度
5. e:表示一个常量
6. exp:返回math.e,也就是2.71828的x次方
7. expm1:返回math.e的x(其值为2.71828)次方的值减１
8. fabs:返回x的绝对值
9. factorial:取x的阶乘的值
10. floor:取小于等于x的最大的整数值，如果x是一个整数，则返回自身
11. fmod:得到x/y的余数，其值是一个浮点数
12. frexp:返回一个元组(m,e),其计算方式为：x分别除0.5和1,得到一个值的范围
13. fsum:对迭代器里的每个元素进行求和操作
14. gcd:返回x和y的最大公约数
15. hypot:如果x是不是无穷大的数字,则返回True,否则返回False
16. isfinite:如果x是正无穷大或负无穷大，则返回True,否则返回False
17. isinf:如果x是正无穷大或负无穷大，则返回True,否则返回False
18. isnan:如果x不是数字True,否则返回False
19. ldexp:返回x*(2**i)的值
20. log:返回x的自然对数，默认以e为基数，base参数给定时，将x的对数返回给定的base,计算式为log(x)/log(base)
21. log10:返回x的以10为底的对数
22. log1p:返回x+1的自然对数(基数为e)的值
23. log2:返回x的基2对数
24. modf:返回由x的小数部分和整数部分组成的元组
25. pi:数字常量，圆周率
26. pow:返回x的y次方，即x**y
27. radians:把角度x转换成弧度
28. sin:求x(x为弧度)的正弦值
29. sqrt:求x的平方根
30. tan:返回x(x为弧度)的正切值
31. trunc:返回x的整数部分

## random

```python
# 导入 random(随机数) 模块
import random
 
print(random.randint(0,9))
```

## open文件操作

### 文件打开的模式

```python
r 读操作（默认）
rb 以二进制的方式读取
w 写操作（每次执行都是从头开始写，如果没有文件，及路径不对会自动创建）
a 追加（每次执行从文件尾写入，如果没有文件，及路径不对会自动创建）
	w和a的区别，w打开时指针在前，a打开时指针在后
r+ 读写（不创建新文件每次读写文件在文件的开头）   替换
w+ 读写（创建新文件，每次读写会覆盖文件内容，指针在文件尾）
a+ 读写（创建新文件，每次读写追加，指针在文件尾）   只能在最后  输出时需进行解码 对象.decode（）
ab+/wb+/ab+ 二进制
```

### 读文件：

```python
f = open("文件夹路径"，“打开的模式”，,encoding="utf-8/gb2312",errors="ignore")   返回文件对象
```

#### 读文件的操作：

```python
f.close()  读之前关闭文件【先保存后关闭】
f.read()  返回文本的所有内容

```

#### 读的方式：

```python
f.read([num])
	num代表读取字符的数量，默认是全部
f.readline（[num]）
	文件读取每一个行，通过\r \n EOF（文件结束标识）来区别每一行
    num代表读取一行几个字符
f.readlines()  
	返回的是一个列表

```

### 写操作

> 默认指针在开头

#### 写的方式

```python
f.write("str")  将str写入文件
f.writelines("str")  逐行一次性写入
f.flush（） 把缓存区的内容写到硬盘【防止文件丢失】

```

### 关闭文件

```python
f.close()
	1.把缓存区的内容写入硬盘【保存】
    2.关闭文件

```

### 读写错误

```python
由于文件读写时都有可能产生IOError

捕获异常：
    try：
        f=open('/path/to/file','r')
    except:             #发生错误怎么办，可有可无
        print("发生错误")
    finally:			#不关是否出错，都要执行
        if f:
            f.close()
 
with open("note1.txt",'r') as f:   #不需要手动关，自动关(自动释放内存)
    f.read(）

```

### 指针

#### seek（）：移动文件读取指针到指定位置

```python
f.seek（p，0） 移动到文件第p个字节处，绝对位置
f.seek（p，1） 移动到相对于当前位置之后的p个字节（文件以二进制方式打开）
f.seek（p，2） 移动到相对于文章尾之后的p个字节（文件以二进制方式打开）

```

#### tell（）：返回文件读取指针的位置



## pillow

### 生成验证码

```python
from PIL import Image,ImageDraw,ImageFont
import random
import io

# im=Image.new("RGB",(100,100),color=(255,255,0))
#
# draw=ImageDraw.Draw(im)
#
# draw.line((0,0,100,100),fill=(200,200,200),width=10)
# for i in range(0,100):
#     draw.point((random.randint(0, 100), random.randint(0, 100)),
#                fill=(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)))
#
# im.show()


class code:
    def __init__(self):
        self.textCon="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ2345678"
        self.textLen=4
        self.width=200
        self.height=50
        self.im=None
        self.lineNum=0
        self.pointNum=0
        self.copyy=None
        self.letters=""
    def randBg(self):
        return (random.randint(0,120), random.randint(0, 120), random.randint(0, 120),255)
    def fg(self):
        return (random.randint(120, 255), random.randint(120, 255), random.randint(120, 255),250)
    def create(self):
        self.copyy=self.randBg()
        self.im=Image.new("RGBA", (self.width, self.height), color=self.copyy)
    def lines(self):
        lineNum=self.lineNum or random.randint(5,7)
        draw = ImageDraw.Draw(self.im)
        for item in range(lineNum):
            place=(random.randint(0,self.width),random.randint(0,self.height),random.randint(0,self.width),random.randint(0,self.height))
            draw.line(place,fill=self.fg(),width=random.randint(1,3))
    def points(self):
        pointNum = self.pointNum or random.randint(50, 80)
        draw = ImageDraw.Draw(self.im)
        for item in range(pointNum ):
            place = (random.randint(0, self.width), random.randint(0, self.height))
            draw.point(place, fill=self.fg())
    def route(self):
        im2=self.im.rotate(random.randint(-30,30))
        im1=Image.new("RGBA",(self.width,self.height),color=self.copyy)
        self.im=Image.composite(im2,im1,im2)
    def texts(self):
        draw = ImageDraw.Draw(self.im)
        for i in range(self.textLen):
            letter=self.textCon[random.randint(0,len(self.textCon)-1)]
            self.letters+=letter.lower()
            if i==0:
                x=i*(self.width/self.textLen)+random.randint(2,10)
            elif i==self.textLen-1:
                x=i*(self.width/self.textLen)+random.randint(-10,-3)
            else:
                x = i * (self.width / self.textLen) + random.randint(-10, 10)
            y=random.randint(-8,8)
            draw.text((x,y),letter,fill=self.fg(),font=ImageFont.truetype("/usr/share/fonts/truetype/ubuntu/Ubuntu-L.ttf",30))
        self.route()
    def output(self):
        self.create()
        self.lines()
        self.points()
        self.texts()
        bt=io.BytesIO()
        self.im.save(bt,"png")
        return bt.getvalue()
#         self.im.show()
#
# cc=code()
# cc.output()

```

### 前台使用

```python
def yanzheng():
    code1=code()
    res=make_response(code1.output())
    res.headers['content-type']='image/png'
    session['yanzheng']=code1.letters
    return res

```

## timeit包

> 程序的运行时间，讲测试的内容封装成函数 ，
>
> 第一个参数：测试内容；第二个参数： 测试的入口文件  （——main——）；第三个参数：numbers为次数

## 机器人

```python
机器人 文件夹
demo.py
进入cmd
输入 pip install qqbot
输入qqbot
新建cmd窗口
输入qq list group
输入 qq send group 组名 要发送的内容
输入 qq send group 好友备注  发发送内容

```

## pygame

# python并发编程

## 进程

* 程序开始运行时，首先就会创建一个主进程

* 在主程序（父进程）下，可以创建新的进程（子进程），子进程依赖主进程；如果主进程结束，程序会退出

* Python提供多进程包：`multiprocessing`

  ```python
  from multiprocessing import Process
  def run(name):
      print("子进程运行中，name={0}".format(name))
      
  if __name__=='__main__': #系统变量，系统创建的
      print('父进程启动')
      p = Process(target=run,args=('test',),name='进程名字')
      # target: 调用对象，args表示调用对象的位置参数元组
      print('子进程将要执行')
      p.start()
      print(p.name)  #p.pid
      p.join()  # 主进程等子进程结束
      print('子进程结束')
  ```

### Process类

常用方法

1. p.start()   : 启动进程，调用该子进程中的p.run()
2. p.run()    : 进程启动时运行的方法，正式它去调用`target`制定的函数，自定义实现必须实现此方法
3. p.terminate()  : 强制终止进程p，不会进行任何清理操作
4. p.is_alive()   : 如果p仍然运行，返回True，用来判断进程是否还在运行
5. p.join([超时时间])  : 主进程等待p终止

#### 常用属性

1. name  ： 当前进程实例别名，默认为Process-N，N是从1开始递增的那整数
2. pid  ： 当前进程实例的PID值

### 全局变量在多个进程中不共享

**进程之间的数据是独立的，默认情况下互不影响**

加global也不改变

#### 进程池

> 用来创建多个进程；
>
> 直接用Process创建不多的子进程数
>
> 用模块Pool创建大批量的进程[可以指定一个最大进程数]；如果池子没满，就会创建新的进程来执行请求；如果池子满了，请求就会等待，等池子中有进程结束才会创建新的进程来执行

```python
from multiprocessing import Pool
import random,time

def work(num):
    print(random.random()*num)
    time.sleep(3)
    
if __name__ == "__main__":
    po=Pool(3) #定义进程池，最大进程数3，不写，默认是CPU核数
    for i in range(10):
        po.apply_async(work,(i,)) #apply_async选择调用的目标，每次循环会用空出来的子进程去调用目标
        po.close() #进程池关闭之后不在接受新的请求
        po.join()  #等待po中所有子进程结束，必须放在close后
       
在多进程中，主进程一般用来等待，真正的任务都在子进程中执行    
```

1. apply_async(函数 [,args [,kargs]]) :使用非阻塞方式调用函数【阻塞就是必须等待上一个进程退出才能进行下一个】,args为参数列表
2. apply(函数 [,args]) : 阻塞方式调用，只能一个一个进程执行
3. close() ：关闭进程池，不再接受新的任务
4. terminate()  :  不管任务是否完成，立即终止
5. join() : 等待po中所有子进程结束，必须放在close/terminate后

### 进程间通信 -Queue

* 多进程之间，默认数据不共享
* 通过Queue（队列Q）可以实现进程间的数据传递的
* Q本身是一个消息队列
* 创建

```python
from multiprocessing import Queue
q=Queue(3)  #初始化Queue，最多可以接受3条消息[共享的]
q.put('消息1')  # 添加消息数据类型不限
q.put('消息2')
q.put('消息3')
q.full()
q.get()  #读取消息
```

1. q=Queue(num) 不写num或者写入负数代表没有上限

2. q.qsize()  : 返回当前队列包含的消息数量

3. q.empty()  : 如果队列为空，返回True

4. q.full()  如果队列满了，返回True

5. q.get（block [,超时时间]） ： 每执行一次，就从队列中拿出一条消息，然后将其从队列中移除；block默认值True
   * block使用默认值，没有设置超时时间，同时消息队列为空，此时被阻塞，知道消息队列读到消息为止
   * 设置了超时时间，到了时间没有消息，抛Queue.Empty异常
   * block使用False，消息队列如果为空，就会立刻抛出Queue.Empty异常

6. q.get_nowait()  :相当于q.get(False)

7. q.put(消息，[block , [超时时间]]) 

8. q.put_nowait(消息) : 相当于q.put(消息，False)

9. 进程池创建的进程之间通信：用multiprocessing.Manager() 中的Queue()

   ```python
   from multiprocessing import Manager,Pool
   import time
   def write(q):
       for i in "wwlcome":
           print('开始写入'+i)
           q.put(i)
           
   def reader(q):
       time.sleep(3)
       for i in range(q.size()):
           print("得到的消息"+q.get())
           
   if __name__=='__main__':
       print("主进程启动")
       q=Manager().Queue()
       po=Pool()
       po.apply_async(write,(q,))
       po.apply_async(reader,(q,))
       po.close()
       po.join()
   ```

## 线程

> 线程：实现进程的一种方式

* 一个进程中，需要同时做多件事，就需要同时运行多个子任务，这个任务就是线程
* 线程又被称为轻量级进程，是更小的执行单元
  * 一个进程可拥有多个并行的线程，当中每一个线程，`共享当前进程的资源`
  * 一个进程中的线程共享相同的内存单元**/内存地址空间** =》可以访问相同的变量和对象，而且同一堆中分配对象==》通信、数据交换、同步操作
  * 由于线程间的通信实在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快

### threading模块

```python
import threading
if __name__ == "__name__":
    # 任何进程默认会启动一个线程，主进程启动的线程叫主线程；主线程可以启动新的子线程
    current_thread()  #返回当前线程实例
    .name  #当前线程的名称
    current_thread().name #主线程的名字
```

```python
import threading,time
def say():
    print("子线程%s启动"%(threading.current_thread().name))
    time.sleep(1)
    print('亲爱的，我错了，我能吃饭了吗？')
    
if __name__ == "__main__":
    print('主线程%s启动'%(threading.current_thread().name))
    for i in range(5):
        t=threading.Thread(target=say [,args=('参数1',),name='名字'])
        t.start()
    
```

* threading.enumerate() ：返回当前运行中的thread对象列表

### 线程的五种状态

### 线程全局变量

* 多线程之间数据共享
* 缺点：可能造成多个线程同时修改一个变量（即线程非安全）,可能造成混乱
* 线程=》IO

### 线程同步

1. 当多个线程几乎同时修改一个共享数据时，需要进行同步控制
2. 线程同步能保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁
3. 互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性（原子性）
4. 互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时其他线程不能更改，知道该线程释放资源；
5. 互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性
6. threading模块中定义了Lock类，可以方便的处理锁定

```python
import threading
num=0
def test1():
    global num
    if mutex.acquire(): #获得锁
        for i in range(1000):
            num += 1
    mutex.release() #释放锁
    
def test2():
    global num
    if mutex.acquire(): #获得锁
        for i in range(1000):
            num += 1
    mutex.release() #释放锁   
    
mutex=threading.Lock()
p1=threading.Thread(target=test1)
p1.start()
p2=threading.Thread(target=test2)
p2.start()
print(num)
```



## 线程和进程的区别

* 进程是系统进行资源分配和调度的一个独立单位
* 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而大大提高了程序的运行效率
* `一个程序至少有一个进程，一个进程至少有一个线程`
* 线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位
* 线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源
* 线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高
* `线程不能独立运行，必须依存在进程中`
* 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反

### 线程同步（死锁）

> 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁

#### Queue模块实现线程同步

1. FIFO(先进先出) 队列Queue

2. LIFO(后入先出) 栈 LifoQueue

3. 优先级队列 PriorityQueue

   **这些队列都实现了锁原语（要么不做，要做就做完），能够在多线程中直接使用**

区别于队列中条目检索的顺序不同

* 在FIFO队列中，按照先进先出的顺序检索条目
* 在LIFO队列中，最后添加的条目最先检索到（操作类似一个栈）
* 在优先级队列中，条目被保存为有序的（使用heapq模块），并且最小值的条目被最先检索

### threadlocal

1. 复杂的

```python
# 字典形式
import threading
class Student:
    def __init__(self,name):
        self.name=name
    def __str__(self):
        return "<Student %s>"%self.name
    
global_dict={}
def deal_stu(name):
    print("线程[%s]执行任务，参数为%s"%(threading.current_thread().getName(),name))
    std=Student(name)
    global global_dict
    global_dict[threading.current_thread()]=std
    fun1()
    fun2()
    
def fun1():
    global global_dict
    std=global_dict[threading.current_thread()]
    print("fun1",std)
    
def fun2():
    global global_dict
    std=global_dict[threading.current_thread()]
    print("fun2",std)  
    
t1=threading.Thread(target=deal_stu,args=('陌陌'),name='momo') 
t2=threading.Thread(target=deal_stu,args=('露露'),name='lulu') 
t1.start()
t2.start()
```

2. 简单的ThreadLocal

   保存自己的私有属性

```python
import threading
threadLocal=threading.local()

class Student:
    def __init__(self,name):
        self.name=name
    def __str__(self):
        return "<Student %s>"%self.name
    
def deal_stu(name):
    # 处理取出
    stu=threadlocal.student
    print("Hello，%s (in %s)"%(stu,threading.current_thread().name))
   
def deal_thread(name)
	print('线程[%s]执行，参数为%s'%(threading.current_thread(),name))
    stu=Student(name)
    # 添加
    threadlocal.student=stu
    deal_stu()

t1=threading.Thread(target=deal_thread,args=('陌陌'),name='momo') 
t2=threading.Thread(target=deal_thread,args=('露露'),name='lulu') 
t1.start()
t2.start()
```

#### 总结

* 全局变量thredLocal就是一个ThreadLocal对象，每个Thread对ThreadLocal变量都可以读写属性，但互不影响
* thredLocal虽然是全局变量，但是每个线程都只能读写到自己线程的独立副本，互不干扰
* thredLocal解决了参数在一个线程中各个函数之间互相传递的问题，真正做到了线程之间的数据隔离
* thredLocal是全局变量，每个属性如thredLocal.stu等都是线程的全局变量，可以任意读写而互不干扰，不考虑锁，thredLocal内部会处理
* 添加thredLocal.teacher=..
* thredLocal最常用的敌方就是为每一个线程绑定一个数据库链接，HTTP请求，用户身份等

## 同步、异步

### 同步调用：确定调用的顺序

### 异步调用：不确定顺序

### 堵塞和非堵塞





## Python 协程 线程 进程

> 进程：软件
>
> 并行：同时实际能做多少事情     =》 6核  6进程
>
> 并发：同时能容纳任务的极限     =》 6核  30个任务   一个处理5个
>
> 解决并发：进程  线程  协程
>
> 进程角度： 资源占用大   同时客气多个进程，完成任务；计算密集型
>
> 线程角度：（Python 线程的并发是假的，同一时刻最多调用一个线程） 一个进程里开启多个线程，但同时只能只能开启一个线程，完成轮循；IO密集型的任务（拷贝）
>
> 协程（纤程）：在一个线程里完成轮循，运用的资源最少，只能处理小型的任务

## 携程yield实现

> yield

```
    def aa():
    while True:
        yield
        print("aa")
        time.sleep()
        
        
     def bb():
    while True:
        yield
        print("bb")
        time.sleep()
     
     one=aa()
     two=bb()
     
     while True:
        next aa()
        next bb()
           
```

# 网络

## IP

A类：0+网络号7位+主机号24位

B类：10+网络号14位+主机号16位

C类：110+网络号21位+主机号8位

D类：1110     =》多点网络  

E类：11110

## 子网掩码

> 区分网络号和主机号

C类子网掩码：255.255.255.0

B类子网掩码：255.255.0.0

A类子网掩码：255.0.0.0

## 端口号

> 用来标记区分进程
>
> 0-65535
>
> 知名端口：0-1023
>
> 动态端口：1024-65535   =》 动态分配不固定

消息：ip+端口

## 协议

> tcp/ip协议族

应用层：

传输层：TCP、UDP

网际层：IP、ICMP、IGMP、ARP、RARP

网络接口层：网络接口【详细：物理层、数据链路层】

## Socket

> 通过网络完成进程间通信的方式
>
> 介于应用层 和 传输层 =》 桥梁

* 对TCP/IP协议的封装

* 连接过程：服务器监听  =》 客户端请求  =》 连接确认

* 实现

```python
import socket
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)  #AF_INET使用ipv4协议，SOCK_STREAM使用UDP/TCP协议
```

## TCP/UDP

### UDP:用户数据报协议

> 传输速度快，不保障质量   

```python
from socket import *
s=socket(AF_INET,SOCK_DGRAM)
# 发送模式1

s.sendto('你好'.encode('GB2312'),('ip',端口)) #消息是字节流的;编码/解码双方一直
# 发送的消息需遵守双方协议
# s.sendto('1:123:发送方:发送方电脑:32:消息'.encode('GB2312'),('ip',端口)) # 飞秋

#接受
redata=s.recvfrom(2048)  #2048数据最大的大小
print(redata)  => (数据,('IP',端口))
redata[0].decode('gb2312') #接受的数据 
s.close()

```



### TCP:传输控制协议

> 发送数据前建立连接（报文握手）

```python
#导入socket模块
from socket import *
#创建Socket对象
tcpServerSocket=socket(AF_INET,SOCK_STREAM)
#绑定端口
# 发送模式2
tcpServerSocket.bind(('',8888))
#监听客户端的连接
tcpServerSocket.listen()
#接收客户端连接
tcpClientSocket,host=tcpServerSocket.accept()
while True:
    #读取客户端的消息
    re_data=tcpClientSocket.recv(1024).decode('utf-8')
    #将消息输出到控制台
    print('客户端说：',re_data)
    if re_data=='end':
        break
    #获取控制台信息
    msg=input('>')
    tcpClientSocket.send(msg.encode('utf-8'))
tcpClientSocket.close()
tcpServerSocket.close()
```

## TFTP简单文件传输协议

> 使用这个协议，既可以实现简单文件的下载
>
> 默认端口：69
>
> 数据：2字节码操作+2个字节的序号+521字节数据

### 构建下载请求

```python
# 数据1test.jpg0octet0
import struct

cmb_buf=struct.pack('!H8sb5sb',1,b"test.jpg",0,b'octet',0)
# !H8sb5sb ： ! 表示按照网络传输数据要求的形式来组织数据（占位的格式）
# H:表示将后面的 1 替换成两个字节
# 8s：相当于8个s；占8个字节
# b占一个字节


#unpack()  解析数据（元组）=》(fmt,string)
# calcsize(fmt) 给定格式（fmt）占多少字节
```

### 下载

```python
from socket import *
import struct

cm=struct.pack('!H7sb5sb',1,b'dog.jpg',0,b'ocret',0)
udpSock=socket(AF_INET,SOCK_DGRAM)
udpSock.sendto(cm,('ip',69))
f=open('dog.jpg','ab')  #读写请求已发送
while True:
    recv_data=s.recvfrom(2048) #接收数据
    caozuoma,ack_num=struct.unpack("!HH",recv_data[0][:4]) #获取数据块编号
    rand_port=recv_data[1][1]  #服务器的随机端口
    if int(caozuoma) == 5:
        print('文件不存在')
        break
    print('操作码:%d,ACK:%d,服务器随机端口：%d,数据长度:%d'%(caozuoma,ack_num,rand_port,len(recv_data)))
    f.write(recv_data[0][4：])
    if len(recv_data[0])<516:
        break
    ack_data=struct.pack('!HH',4,ack_num)
    s.sendto(ack_data,('ip',rand_port))  #回复ACK确认包
```

## 广播

```python
from socket import *
dest=("<broadcast>",8080)
s=socket(AF_INET,SOCK_DGRAM)  #udp
s.setsockopt(SOL_SOCKET,SO_BROADCAST,1)

s.sendto(b'hello',dest)
while True:
    s.recvfrom()
```

## TCP服务器

```python
from socket import *
tcpSock=socket(AF_INET,SOCK_STREAM)
tcpSock.bind(('',7788))  #ip不写默认是本机
tcpSock.listen(5)  #最大连接数
newSock,clientAddr=tcpSock.accept()
data=newSock.recv(1024)
print(data)
newSock.send(b'谢谢')

newSock.close()
tcpSock.close()
```

## TCP客户端

```python
from socket import *
clientSock=socket(AF_INET,SOCK_STREAM)
clientSock.connect(('192.168.1.17',7788))  #三次握手
clientSock.send(b'我是客户端')
data=clientSock.recv(1024)
print(data)
clientSock.close()

```

## 多进程服务器

```python
from socket import *
from multiprocessing import *
from time import sleep
# 处理客户端的请求并为其服务
def dealClient(newSocket,deatAddr):
    while True:
        recvData=newSocket.recv(1024)
        if len(recvData)>0:
            print('recv[%s]:%s'%(str(destAddr),recvData))
        else:
            print('[%s]客户端已经关闭'%(str(destAddr)))
            break
    newSocket.close()
    
def main():
    serSocket=socket(AF_INET,SPCK_STREAM)
    serSocket.setspckopt(SOL_SOCKET,SO_REUSEADDR,1)
    localAddr=('',7788)
    serSocket.bind(localAddr)
    serSocket.listen(5)
    try:
        while True:
            print("主进程等新客户来：")
            newSocket,destAddr=serSocket.accept()
            print('主进程创建一个新进程负责数据处理')
            client=Process(target=dealClient,args=(newSocket,deatAddr))
            client.start()
            newSocket.close() #线程不需要
    finally:
        serSocket.close()
    
if __name__ == '__main__':
    main()
```





# pip

> python用pip安装模块（发布上线的）

## 安装

1. pip install 安装的包名 == 版本号

   > 不指定版本，默认最新
   >
   > pip install SomePackage>=1.0.4 最低版本的
   >
   > pip install pyinstaller（没有python的用户也可以用）
   > 默认安装在python的安装目录下的site-packages文件夹下

2. file -> setting ->project ->project Interpreter

## 卸载

pip uninstall 包名

## 查看已经安装的包

> pip show --files SomePackage

## 列出已经安装的包

> ```
> pip list
> ```

## 检查哪些包需要更新

> pip list --outdated

## 升级包

> pip install --upgrade SomePackage

## 卸载包

> pip uninstall SomePackage

## 使用pip工具把本机已安装的Python扩展库及版本信息输出到文本文件requirements.txt中的完整命令是:

> ```python
> 导出：pip freeze >requirement.txt
> 
> 安装：pip install -r requirement.txt
> ```





# 解方程

> 解方程的基本思想是：
>
> aa = solve([f],[x])
>
> f是方程，x是变量，这个代码解的是关于x的方程f=0
>
> 既然可以解方程（组），就一定可以解微分方程（组）。 

```python
from sympy import *
from sympy.abc import a,b,c,x,y
aa=solve([x+a],[x])  得到x的解

需要数值解？很简单，在某个数字后面加一个小数点就行了。

aa = solve([sin(x+y),cos(x-3.*y)],[x,y])

```

## 解二次方程

```python
aa = solve([x**2+a**2],[x])
```

## 解三次方程

```python
aa = solve([x**3+a**3],[x])
```

## 解四次方程是比较费劲

```python
aa = solve([x**3+c*x+1],[x])
```

## 解超越方程：

```python
aa = solve([sin(x)],[x])
```

## 解方程组：

```python
aa = solve([x+y-3,2x+3y-12],[x,y])
for i in aa:

    for j in i:

        print(j,"\n")
```

## 解超越方程

```python
aa = solve([sin(x+y),cos(x-3*y)],[x,y])
for i in aa:

    print(i)
```

# GUI编程

>  图形图像用户界面

## tkinter编程的步骤：

```pyth
1. 导入tkinter模块
2. 创建一个顶层对象，容纳整个GUI应用
3. 在顶层窗口之上（或者‘其中’）所有的GUI组件（及其功能）
4. 通过底层的应用代码讲这些GUI组件连接
5. 进入主事件循环

代码如下：
import tkinter as tk  #导包
#主窗口
window = tk.Tk()   #创建窗口
window.title("我的窗口")   #设置窗口名字
window.geometry('1200x500')   #设置窗口尺寸
window.resizable(0,0)    #重置窗口大小resizable(x轴,y轴)的范围 
window['bg']='yellowgreen'

...

window.mainloop()   #进行时件主循环
```

## 布局管理

### place

> 绝对布局，组件的大小和位置不会随着窗口的大小而改变

> 他的做法非常直接，提供空间大小和摆放位置，然后管理器就会将其摆放好。问题是  你必须对所有的控件进行操作，这样就会加重变成开大的负担，因为这些操作本应该是自动完成的
>
> 对象.place(x=100,y=100)

```python
f1.place()

f1.place(x=100,y=100,height=200,width=200)
#height/width    指定容器的大小
#x/y   相对于父元素  x轴的偏移量，y轴的偏移量
#relx/rely   参照于父元素  x y
#relwidth/relheight   [0-1]   参照与父元素的width和height

f2=tk.Frame(f1,width=100,height=100,bg='red')
f2.place(relx=0.1,rely=0.1)
```



### pack

> 相对布局，组建的大小和位置会随着窗口的大小而改变

> 把控件填充到正确的位置（即指定的父控件中，然后对于之后的每个控件，回去寻找剩余的空间进行填充。这个处理很像旅行时往行李箱中填充行李的进程）

```python
pack中的参数/属性
anchor=‘’   #anchor锚位值，当剩余空间远远大于所需空间,
side='top/left'     #对齐方式top/left/bottom/right/tk.TOP/tk.LEFT/tk.BOTTOM/tk.RIGHT
fill=tk.X  #fill 填充，tk.X/tk.Y/x/y
expand=1   #expand   扩充，展开
padx/pady        #外间距
ipadx/ipady=10   #内间距


pack的方法：
组件.pack_forgrt()    消失/隐藏
```



### griｄ

> 通过表格形式进行布局

> 你可以基于网络的坐标，使用Ｇｉｒｄ来指定ＧＵＩ控件的位置，ｇｉｒｄ会在他们的网络位置上类渲染ＧＵＩ应用中的每个对象

```python
b1=tk.Button(window,height=6,width=3,text='1')
b1.grid(row=0,column=0,padx=10,pady=2)
#row=0,column=0,   位置
#padx=10,pady=2    外间距
#columnspan=2 横跨两列
#rowspan=2    横跨两行
#sticky   组件在表格内的方位
```



## 组件

### 基本属性（通用）

```python
实例['text']="hello world"   #定义文字
实例['font']=('字体名称',字体大小，'字体样式【倾斜 加粗等】') 
实例['bg']='blue'  背景色
实例['fg']='#fff'   字体颜色
实例['width']=50      # 文本的宽度
实例['height']=10       # 文本的高度   (相对于文字的大小）
```

### Ｌａｂｅｌ标签（存放文字）

```pyhton
设置默认字
# str1=tk.StringVar()
# str1.set('ygxygx') 


img1=tk.PhotoImage(file='1.png')   #插入图片
l1=tk.Label(window,text='杨国璇',font=('',20,'bold italic'),fg='#b0b0b0')  #定义文字
# l1['text']="hello world"   #定义文字
# l1['font']=('字体名称',字体大小，'字体样式【倾斜 加粗等】') 
# l1['bg']='blue'  背景色
# l1['fg']='#fff'   字体颜色
l1['width']=50      # 文本的宽度
l1['height']=10       # 文本的高度
l1['anchor']='c'         #文字的位置[东e西w南s北n ne nw se sw c居中]
# l1['value']='this is ygx'
# l1['variable']=''
# l1['image']=img1    #添加图片

或者：
l1.config({
    'text':'this is label',
    'fg'='',
    'bg'='',
    'font'=('','','')
})

l1.pack()
```

### button按钮

```python
num=0
def aa():
    global num
    l1['text']='杨国璇%d'%(num)
    num+=1
    print(123)
#button   按钮
b1=tk.Button(window,text='点击',width=20,height=2,bg='blue',fg='red',font=('',30,''),command=aa)
#command   事件处理指定的操作

特殊属性
activebackground     #选中文字的背景色
activeforeground     #选中文字的前景色
state=disable/normal     #按钮的状态：不可选/正常

```

### 输入组件 entry

```python
设置变量：
v1=tk.Variable()
v1.set(0)


e1=tk.Entry(window,textvariable=v1,validate="focusout",validatecommand=fn1,invalidcommand=fn2)
v1指向e1 
#validate   验证    
	# focus焦点    focusin获取焦点的时候    focusout失去焦点的时候     key用户输入的时候验证
#validatecommand验证通过触发的操作
# invalidcommand验证没通过触发的操作
e2=tk.Entry(window,textvariable=v2,validate="focusout",validatecommand=fn3,invalidcommand=fn4)
e2['show']="璇"    #输入的样式
e2['selectbackground']='red'   选中文字的背景色
e2['selectforeground']='blue'    选中文字的颜色
```

### 文本域

```python
t=tk.Text(window)
t.insert('insert/end',var)   插入的方式，内容
#获取文本域的内容
con=t.get('0.0','end')
```

### 单选按钮

```python
v1=tk.Variable()    #实例
v1.set("A")    #清除默认点击效果
def fn():
    con=v1.get()
    l1['text']='你选择了:%s 选项'%con
#单选按钮
r1=tk.Radiobutton(window,text="A",variable=v1,value="A",command=fn)
r2=tk.Radiobutton(window,text="B",variable=v1,value="B",command=fn)
r3=tk.Radiobutton(window,text="C",variable=v1,value="C",command=fn)

实例：
import tkinter as tk
# import random

window=tk.Tk()  #创建窗口
window.title("我的窗口")  #设置窗口的title
window.geometry('600x400') #设置窗口尺寸
window.resizable(0,0) #重置尺寸的大小，范围

v1=tk.Variable()    #实例
v1.set("A")    #清除默认点击效果
def fn():
    con=v1.get()
    l1['text']='你选择了:%s 选项'%con
#单选按钮
r1=tk.Radiobutton(window,text="A",variable=v1,value="A",command=fn)
r2=tk.Radiobutton(window,text="B",variable=v1,value="B",command=fn)
r3=tk.Radiobutton(window,text="C",variable=v1,value="C",command=fn)

l1=tk.Label(window,font=("",20,"bold italic"))
l1['text']='您选择的是：'
l1['height']=3
l1['width']=150
l1['bg']='red'
l1.pack()
r1.pack()
r2.pack()
r3.pack()
window.mainloop() 
```

### 多选/复选

```python
c1=tk.Checkbutton(window,text='看电影',variable=v1,command=fn)
c1.pack()
c2=tk.Checkbutton(window,text='敲代码',variable=v2,command=fn)
c2.pack()

实例
import tkinter as tk

window=tk.Tk()
window.title('ygx')
window.geometry('600x200')

#checkbutton
v1=tk.Variable()
v2=tk.Variable()
v1.set(0)
v2.set(0)

def fn():
    con1=int(v1.get())
    con2=int(v2.get())
    if con1==1 and con2==0:
        l['text']='我喜欢看电影'
    elif con1==0 and con2==1:
        l['text']='我喜欢敲代码'
    elif con1==0 and con2==0:
        l.config(text='我既不喜欢看电影也不喜欢敲代码')
    else:
        l.config(text='我既喜欢看电影也喜欢敲代码')


l=tk.Label(window,width=60,height=3,bg='#333',font=('',20,''))
l['fg']='#000'
l.pack()
c1=tk.Checkbutton(window,text='看电影',variable=v1,command=fn)
c1.pack()
c2=tk.Checkbutton(window,text='敲代码',variable=v2,command=fn)
c2.pack()

window.mainloop()
```

### 下拉列表

```python
lx1=tk.ListBox(window,selectmode='extended')   #selectmode  多选
lx1.insert(0,'插入的内容')    #插入方式，内容
lx1.curselection()   #选中数据的下表       返回的是元素元组

实例：
import pickle,csv
import tkinter as tk

window=tk.Tk()
window.title('ygx')
window.geometry('600x200')

v1=tk.StringVar()
v1.set("")

l=tk.Label(window,width=20,height=2,bg='green',fg='red')
l.pack()

en=tk.Entry(window,textvariable=v1)
en.pack()

def fn1():
    arr=lx1.curselection()   #选中数据的下标，返回一个元组
    con=en.get()         #输入框文字
    didian.append(con)
    if len(con)==0:
        return
    if len(arr)==0:
        lx1.insert('end',con)
        v1.set('')
    elif len(arr)==1:
        lx1.insert(arr[0]+1,con)
        v1.set('')
    else:
        num=1
        for i in arr:
            lx1.insert(i+num,con)
            num+=1
        v1.set('')
    savecsv()
    savepickle()
b1=tk.Button(window,text='插入',command=fn1)
b1.pack()

#列表listbox
lx1=tk.Listbox(window,selectmode='extended')
#selectmode选择的模式
# didian=['北京','大同','上海','南京','杭州']
# with open('madata','wb') as f:
#     pickle.dump(didian,f)
def savepickle():
    with open('mydata','wb') as f:
        pickle.dump(didian,f)
#保存数据为csv格式
def savecsv():
    with open("xinxi.csv",'w',newline="") as f:
        writer=csv.writer(f,dialect="excel")
        for i in didian:
            writer.writerow(i)
f=None
try:
    f=open("mydata",'rb')
    didian=pickle.load(f)
except:
    print("获取数据失败")
    didian=[]
finally:
    if f!=None:
        f.close()
savecsv()
savepickle()

# lx1.insert(0,'北京')
for i in didian:
    lx1.insert('end',i)
lx1.pack()

def fn():
    print(lx1.curselection())

b=tk.Button(window,text='点击',command=fn)
b.pack()

window.mainloop()
```

### scale滑块

```python
import tkinter as tk
window=tk.Tk()
window.geometry('600x300')

l1=tk.Label(window)
l1.config({
    'text':'温度是：%d°C'%50,
    'fg':'red',
    'height':2,
    'width':100
})
l1.pack()
#scale滑块

def fn1(v):
    con=int(s1.get())
    l1['text']=' 温度是：%d°C'%con,
    l11=l1['text']

    if con<100:
        l1['text']+=',好凉快啊'
    elif con>=100 and con <150:
        l1['text']+=',舒服'
    else:
        l1['text']=l11+'，热死了'

s1=tk.Scale(window,command=fn1)
s1.config({
    'orient':tk.HORIZONTAL,    #滑块水平方向，默认竖着
    'from':50,
    'to':200,
    'length':300,              #滑块的大小
    'resolution':10,           #滑一次的步进值
    # 'digits':5,                #显示的数字的位数（小数点）
    'tickinterval':50,         #间隔的刻度，数值最小是步进值的一半
    'showvalue':1,             #布尔值0/1，1是显示刻度(上方的值)，0是不显示
    'label':'文都',            #给滑块添加标签
})

s1.pack()

# b1=tk.Button(window,text='提交',command=fn1)

# b1.pack()

window.mainloop()
```

### spinbox 数字框

```python
#spinbox，数字框，没有set方法
def fn2():
    con=int(s2.get())
    l1['text']='温馨提醒，今天的温度是 %d °C,请注意增减衣物，以防感冒。'%con
    s1.set(con)
    
s2=tk.Spinbox(window,command=fn2)
s2.config({
    'from':19,
    'to':43,
    'width':20,   #没有height，length
    # 'value':int(s1.get()),    #设置默认值,有默认值时不能点
    #'values':('北京','上海','广州')
})
s2.pack()

```

### canvas画布

```python
#canvas画布
canvas=tk.Canvas(window)
canvas.config({
    'width':600,
    'height':600,
    'bg':'#b0b0b0'
})
img1=tk.PhotoImage(file='1.png',width=100,height=100)
cimg=canvas.create_image(0,0,image=img1)   #画图
cline=canvas.create_line(0,0,200,200,fill='red')    #划线,fill填充色
carc=canvas.create_arc(200,200,300,300,start=90,extent=270,fill='yellow')       #开始坐标，结束坐标，画扇形,从90度开始，画270度
coval=canvas.create_oval(300,300,350,350)               #画多边形
ctext=canvas.create_text(50,50,text='python',font=('',20,''))   #写字
cp=canvas.create_polygon(0,0,0,100,100,100,fill='green')    #多边形的顶点角标位置
cr=canvas.create_rectangle(300,300,500,500,fill='pink')     #正方形
canvas.move(cr,-50,-50)
```

### menu菜单栏

```python
#菜单栏
#通过menu创建
menubar=tk.Menu(window)     #创建菜单栏
menu1=tk.Menu(menubar,tearoff=0)      #创建菜单项,tearoff取消自由移动 ，值为1/False
menu1.add_command(label='新建文件')   #添加内容
menu1.add_command(label='新建窗口')

menu2=tk.Menu(menu1,tearoff=0)
menu2.add_command(label='设置')

menu1.add_cascade(label='首选项',menu=menu2)
menubar.add_cascade(label='文件',menu=menu1)

window.configure(menu=menubar)         #添加菜单栏

#设置分割线
# menu1.add_separator()

#创建单选
menu1_1.add_radiobutton(label=j,variable=yuyan,value=n)
#创建多选
menu1_1.add_checkbutton(label=j,variable=k,command=fn2)
```

### 右键菜单

```python
import tkinter as tk

window=tk.Tk()
window.geometry('600x600')

menubar=tk.Menu(window,tearoff=0)
for i in ['css','html','js','python']:
    menubar.add_command(label=i)
def click(e):
    menubar.post(e.x_root,e.y_root)
window.bind('<Button-3>',click)

window.mainloop()
```

### 添加小图标

```python
img1=tk.PhotoImage(file='',height=10,width=10)
menu1.add.command(label='设置',command=fn,image=img,compound='left')
#  compound  对齐方式
```

### frame  框

```python
f1=tk.Frame(window,width=200,height=200,bg='red')
```

### 弹框

```python
提示型弹框
    tk.messagebox.showerror(title='error',message='出现错误')  #错误弹框
    tk.messagebox.showinfo(title='info',message='您选择了科学型计算机')   #提示型弹框
    tk.messagebox.showwarning(title='warning',message='这是一个警告')    #警告型弹框

    询问框
    b=tk.messagebox.askyesno(title='ask',message='确定关闭？')    #是/否
        print(b)   # 返回布尔值True/False
    b=tk.messagebox.askokcancel(title='ask',message='确定退出？')    #确定/取消
        print(b)   # 返回布尔值True/False
    b=tk.messagebox.askquestion(title='ask',message='确定退出？')    #是/否
        print(b)   # 返回布尔值Yes/No
    b=tk.messagebox.askretrycancel(title='ask',message='程序未响应，是否退出？')    #重试/取消
        print(b)   # 返回布尔值True/False
    b=tk.messagebox.askyesnocancel(title='ask',message='22')     #是/否/取消
        print(b)    #返回值True/False/None
```

### 滚动条

```python
s=tk.Scrollbar(f)
s.pack(fill=tk.Y,side=tk.RIGHT)
```

## 事件

### 鼠标事件

```python
window.bind('<Button-1>',lambda x:print('左击'))
window.bind('<Button-2>',lambda x:print('中间键'))
window.bind('<Button-3>',lambda x:print('右击'))
window.bind('<Button-4>',lambda x:print('滚轮向上滚动'))
window.bind('<Button-5>',lambda x:print('滚轮向下滚动'))


window.bind('<Double-Button-1>',lambda x:print('左键双击'))
window.bind('<Double-Button-2>',lambda x:print('中间键双击'))
window.bind('<Double-Button-3>',lambda x:print('右键双击'))

window.bind('<Triple-Button-1>',lambda x:print('左键三击'))
window.bind('<Triple-Button-2>',lambda x:print('中间键三击'))
window.bind('<Triple-Button-3>',lambda x:print('右键三击'))

window.bind('<B1-Motion>',lambda x:print('左键移动'))  #按下移动
window.bind('<ButtonRelease-1>',lambda x:print('左键抬起'))
window.bind('<Enter>',lambda x:print('鼠标移入'))
window.bind('<Leave>',lambda x:print('鼠标移入'))

```

### 键盘事件

```python
e.bind('<Key>',lambda x:print("键盘按下"))
e.bind('<KeyRelease>',lambda y:print('键盘抬起'))

e.bind('<Return>',lambda x:print('回车'))
e.bind('<Up>',lambda x:print('上'))
e.bind('<Down>',lambda x:print('下'))
e.bind('<Left>',lambda x:print('左'))
e.bind('<Right>',lambda x:print('右'))

e.bind('<Shift_L>',lambda x:print('左shift'))
e.bind('<Shift_R>',lambda x:print('右shift'))

e.bind('<Control-L>',lambda x:print('左ctrl'))
e.bind('<Control-R>',lambda x:print('右ctrl'))

e.bind('<Alt_L>',lambda x:print('Alt_L'))

e.bind('<a>',lambda x:print('a'))
e.bind('<A>',lambda x:print('A'))
组合键
e.bind('<Shift-r>',lambda x:print('shift-r'))
```

### 键盘码等

- keycode    键盘码
- keysym      键盘符
- char           字符
- widget       事件源
- x
- y   相对于（当前的）窗口的位置
- x_root
- y_root    相对于（当前的）屏幕的位置